Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    UMINUS
    UPLUS
    UTIMES

Grammar

Rule 0     S' -> program
Rule 1     program -> global_declaration_list
Rule 2     global_declaration_list -> global_declaration
Rule 3     global_declaration_list -> global_declaration_list global_declaration
Rule 4     global_declaration -> function_definition
Rule 5     global_declaration -> declaration
Rule 6     function_definition -> declarator declaration_list compound_statement
Rule 7     function_definition -> type_specifier declarator declaration_list compound_statement
Rule 8     declaration_list -> declaration
Rule 9     declaration_list -> declaration_list declaration
Rule 10    identifier -> ID
Rule 11    type_specifier -> VOID
Rule 12    type_specifier -> CHAR
Rule 13    type_specifier -> INT
Rule 14    type_specifier -> FLOAT
Rule 15    pointer -> TIMES
Rule 16    pointer -> TIMES pointer
Rule 17    declarator -> direct_declarator
Rule 18    declarator -> pointer direct_declarator
Rule 19    direct_declarator -> identifier
Rule 20    direct_declarator -> declarator
Rule 21    direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET
Rule 22    direct_declarator -> direct_declarator LPAREN parameter_list RPAREN
Rule 23    direct_declarator -> direct_declarator LPAREN identifier RPAREN
Rule 24    constant_expression_opt -> constant_expression
Rule 25    constant_expression_opt -> empty
Rule 26    constant_expression -> binary_expression
Rule 27    binary_expression -> cast_expression
Rule 28    binary_expression -> binary_expression TIMES binary_expression
Rule 29    binary_expression -> binary_expression DIVIDE binary_expression
Rule 30    binary_expression -> binary_expression MOD binary_expression
Rule 31    binary_expression -> binary_expression PLUS binary_expression
Rule 32    binary_expression -> binary_expression MINUS binary_expression
Rule 33    binary_expression -> binary_expression LT binary_expression
Rule 34    binary_expression -> binary_expression LE binary_expression
Rule 35    binary_expression -> binary_expression GT binary_expression
Rule 36    binary_expression -> binary_expression GE binary_expression
Rule 37    binary_expression -> binary_expression EQ binary_expression
Rule 38    binary_expression -> binary_expression NQ binary_expression
Rule 39    binary_expression -> binary_expression AND binary_expression
Rule 40    binary_expression -> binary_expression OR binary_expression
Rule 41    cast_expression -> unary_expression
Rule 42    cast_expression -> LPAREN type_specifier RPAREN cast_expression
Rule 43    unary_expression -> postfix_expression
Rule 44    unary_expression -> INCREASE unary_expression
Rule 45    unary_expression -> DECREASE unary_expression
Rule 46    unary_expression -> unary_operator cast_expression
Rule 47    postfix_expression -> primary_expression
Rule 48    postfix_expression -> postfix_expression LBRACKET expression RBRACKET
Rule 49    postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN
Rule 50    postfix_expression -> postfix_expression INCREASE
Rule 51    postfix_expression -> postfix_expression DECREASE
Rule 52    argument_expression_opt -> argument_expression
Rule 53    argument_expression_opt -> empty
Rule 54    primary_expression -> identifier
Rule 55    primary_expression -> constant
Rule 56    primary_expression -> STRING
Rule 57    primary_expression -> expression
Rule 58    constant -> INT_CONST
Rule 59    constant -> CHAR_CONST
Rule 60    constant -> FLOAT_CONST
Rule 61    expression -> assignment_expression
Rule 62    expression -> expression COMMA assignment_expression
Rule 63    argument_expression -> assignment_expression
Rule 64    argument_expression -> argument_expression COMMA assignment_expression
Rule 65    assignment_expression -> binary_expression
Rule 66    assignment_expression -> unary_expression assignment_operator assignment_expression
Rule 67    assignment_operator -> EQUALS
Rule 68    assignment_operator -> EQTIMES
Rule 69    assignment_operator -> EQDIV
Rule 70    assignment_operator -> EQMOD
Rule 71    assignment_operator -> EQPLUS
Rule 72    assignment_operator -> EQMINUS
Rule 73    unary_operator -> ADDRESS
Rule 74    unary_operator -> TIMES
Rule 75    unary_operator -> PLUS
Rule 76    unary_operator -> MINUS
Rule 77    unary_operator -> NOT
Rule 78    parameter_list -> parameter_declaration
Rule 79    parameter_list -> parameter_list COMMA parameter_declaration
Rule 80    parameter_declaration -> type_specifier declarator
Rule 81    declaration -> type_specifier init_declarator_list_opt SEMI
Rule 82    init_declarator_list_opt -> init_declarator_list
Rule 83    init_declarator_list_opt -> empty
Rule 84    init_declarator_list -> init_declarator
Rule 85    init_declarator_list -> init_declarator_list COMMA init_declarator
Rule 86    init_declarator -> declarator
Rule 87    init_declarator -> declarator EQUALS initializer
Rule 88    initializer -> assignment_expression
Rule 89    initializer -> initializer_list
Rule 90    initializer -> initializer_list COMMA
Rule 91    initializer_list -> initializer
Rule 92    initializer_list -> initializer_list COMMA initializer
Rule 93    compound_statement -> declaration_list statement_list
Rule 94    statement_list -> statement
Rule 95    statement_list -> statement_list statement
Rule 96    statement -> expression_statement
Rule 97    statement -> compound_statement
Rule 98    statement -> selection_statement
Rule 99    statement -> iteration_statement
Rule 100   statement -> jump_statement
Rule 101   statement -> assert_statement
Rule 102   statement -> print_statement
Rule 103   statement -> read_statement
Rule 104   expression_statement -> expression_opt SEMI
Rule 105   expression_opt -> expression
Rule 106   expression_opt -> empty
Rule 107   selection_statement -> IF LPAREN expression RPAREN statement
Rule 108   selection_statement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 109   iteration_statement -> WHILE LPAREN expression RPAREN statement
Rule 110   iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
Rule 111   iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
Rule 112   jump_statement -> BREAK
Rule 113   jump_statement -> RETURN expression_opt SEMI
Rule 114   assert_statement -> ASSERT expression SEMI
Rule 115   print_statement -> PRINT LPAREN expression_opt RPAREN SEMI
Rule 116   read_statement -> READ LPAREN argument_expression RPAREN SEMI
Rule 117   empty -> <empty>

Terminals, with rules where they appear

ADDRESS              : 73
AND                  : 39
ASSERT               : 114
BREAK                : 112
CHAR                 : 12
CHAR_CONST           : 59
COMMA                : 62 64 79 85 90 92
DECREASE             : 45 51
DIVIDE               : 29
ELSE                 : 108
EQ                   : 37
EQDIV                : 69
EQMINUS              : 72
EQMOD                : 70
EQPLUS               : 71
EQTIMES              : 68
EQUALS               : 67 87
FLOAT                : 14
FLOAT_CONST          : 60
FOR                  : 110 111
GE                   : 36
GT                   : 35
ID                   : 10
IF                   : 107 108
INCREASE             : 44 50
INT                  : 13
INT_CONST            : 58
LBRACKET             : 21 48
LE                   : 34
LPAREN               : 22 23 42 49 107 108 109 110 111 115 116
LT                   : 33
MINUS                : 32 76
MOD                  : 30
NOT                  : 77
NQ                   : 38
OR                   : 40
PLUS                 : 31 75
PRINT                : 115
RBRACKET             : 21 48
READ                 : 116
RETURN               : 113
RPAREN               : 22 23 42 49 107 108 109 110 111 115 116
SEMI                 : 81 104 110 110 111 111 113 114 115 116
STRING               : 56
TIMES                : 15 16 28 74
UMINUS               : 
UPLUS                : 
UTIMES               : 
VOID                 : 11
WHILE                : 109
error                : 

Nonterminals, with rules where they appear

argument_expression  : 52 64 116
argument_expression_opt : 49
assert_statement     : 101
assignment_expression : 61 62 63 64 66 88
assignment_operator  : 66
binary_expression    : 26 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 65
cast_expression      : 27 42 46
compound_statement   : 6 7 97
constant             : 55
constant_expression  : 24
constant_expression_opt : 21
declaration          : 5 8 9 111
declaration_list     : 6 7 9 93
declarator           : 6 7 20 80 86 87
direct_declarator    : 17 18 21 22 23
empty                : 25 53 83 106
expression           : 48 57 62 105 107 108 109 114
expression_opt       : 104 110 110 110 111 111 113 115
expression_statement : 96
function_definition  : 4
global_declaration   : 2 3
global_declaration_list : 1 3
identifier           : 19 23 54
init_declarator      : 84 85
init_declarator_list : 82 85
init_declarator_list_opt : 81
initializer          : 87 91 92
initializer_list     : 89 90 92
iteration_statement  : 99
jump_statement       : 100
parameter_declaration : 78 79
parameter_list       : 22 79
pointer              : 16 18
postfix_expression   : 43 48 49 50 51
primary_expression   : 47
print_statement      : 102
program              : 0
read_statement       : 103
selection_statement  : 98
statement            : 94 95 107 108 108 109 110 111
statement_list       : 93 95
type_specifier       : 7 42 80 81
unary_expression     : 41 44 45 66
unary_operator       : 46

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . global_declaration_list
    (2) global_declaration_list -> . global_declaration
    (3) global_declaration_list -> . global_declaration_list global_declaration
    (4) global_declaration -> . function_definition
    (5) global_declaration -> . declaration
    (6) function_definition -> . declarator declaration_list compound_statement
    (7) function_definition -> . type_specifier declarator declaration_list compound_statement
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer
    (10) identifier -> . ID

    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    TIMES           shift and go to state 15
    ID              shift and go to state 16

    program                        shift and go to state 1
    global_declaration_list        shift and go to state 2
    global_declaration             shift and go to state 3
    function_definition            shift and go to state 4
    declaration                    shift and go to state 5
    declarator                     shift and go to state 6
    type_specifier                 shift and go to state 7
    direct_declarator              shift and go to state 8
    pointer                        shift and go to state 9
    identifier                     shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> global_declaration_list .
    (3) global_declaration_list -> global_declaration_list . global_declaration
    (4) global_declaration -> . function_definition
    (5) global_declaration -> . declaration
    (6) function_definition -> . declarator declaration_list compound_statement
    (7) function_definition -> . type_specifier declarator declaration_list compound_statement
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer
    (10) identifier -> . ID

    $end            reduce using rule 1 (program -> global_declaration_list .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    TIMES           shift and go to state 15
    ID              shift and go to state 16

    global_declaration             shift and go to state 17
    function_definition            shift and go to state 4
    declaration                    shift and go to state 5
    declarator                     shift and go to state 6
    type_specifier                 shift and go to state 7
    direct_declarator              shift and go to state 8
    pointer                        shift and go to state 9
    identifier                     shift and go to state 14

state 3

    (2) global_declaration_list -> global_declaration .

    VOID            reduce using rule 2 (global_declaration_list -> global_declaration .)
    CHAR            reduce using rule 2 (global_declaration_list -> global_declaration .)
    INT             reduce using rule 2 (global_declaration_list -> global_declaration .)
    FLOAT           reduce using rule 2 (global_declaration_list -> global_declaration .)
    TIMES           reduce using rule 2 (global_declaration_list -> global_declaration .)
    ID              reduce using rule 2 (global_declaration_list -> global_declaration .)
    $end            reduce using rule 2 (global_declaration_list -> global_declaration .)


state 4

    (4) global_declaration -> function_definition .

    VOID            reduce using rule 4 (global_declaration -> function_definition .)
    CHAR            reduce using rule 4 (global_declaration -> function_definition .)
    INT             reduce using rule 4 (global_declaration -> function_definition .)
    FLOAT           reduce using rule 4 (global_declaration -> function_definition .)
    TIMES           reduce using rule 4 (global_declaration -> function_definition .)
    ID              reduce using rule 4 (global_declaration -> function_definition .)
    $end            reduce using rule 4 (global_declaration -> function_definition .)


state 5

    (5) global_declaration -> declaration .

    VOID            reduce using rule 5 (global_declaration -> declaration .)
    CHAR            reduce using rule 5 (global_declaration -> declaration .)
    INT             reduce using rule 5 (global_declaration -> declaration .)
    FLOAT           reduce using rule 5 (global_declaration -> declaration .)
    TIMES           reduce using rule 5 (global_declaration -> declaration .)
    ID              reduce using rule 5 (global_declaration -> declaration .)
    $end            reduce using rule 5 (global_declaration -> declaration .)


state 6

    (6) function_definition -> declarator . declaration_list compound_statement
    (20) direct_declarator -> declarator .
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    LBRACKET        reduce using rule 20 (direct_declarator -> declarator .)
    LPAREN          reduce using rule 20 (direct_declarator -> declarator .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

  ! VOID            [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! CHAR            [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! INT             [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! FLOAT           [ reduce using rule 20 (direct_declarator -> declarator .) ]

    declaration_list               shift and go to state 18
    declaration                    shift and go to state 19
    type_specifier                 shift and go to state 20

state 7

    (7) function_definition -> type_specifier . declarator declaration_list compound_statement
    (81) declaration -> type_specifier . init_declarator_list_opt SEMI
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (82) init_declarator_list_opt -> . init_declarator_list
    (83) init_declarator_list_opt -> . empty
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer
    (84) init_declarator_list -> . init_declarator
    (85) init_declarator_list -> . init_declarator_list COMMA init_declarator
    (117) empty -> .
    (10) identifier -> . ID
    (86) init_declarator -> . declarator
    (87) init_declarator -> . declarator EQUALS initializer

    TIMES           shift and go to state 15
    SEMI            reduce using rule 117 (empty -> .)
    ID              shift and go to state 16

    declarator                     shift and go to state 21
    init_declarator_list_opt       shift and go to state 22
    direct_declarator              shift and go to state 8
    pointer                        shift and go to state 9
    init_declarator_list           shift and go to state 23
    empty                          shift and go to state 24
    identifier                     shift and go to state 14
    init_declarator                shift and go to state 25

state 8

    (17) declarator -> direct_declarator .
    (21) direct_declarator -> direct_declarator . LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> direct_declarator . LPAREN parameter_list RPAREN
    (23) direct_declarator -> direct_declarator . LPAREN identifier RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    VOID            reduce using rule 17 (declarator -> direct_declarator .)
    CHAR            reduce using rule 17 (declarator -> direct_declarator .)
    INT             reduce using rule 17 (declarator -> direct_declarator .)
    FLOAT           reduce using rule 17 (declarator -> direct_declarator .)
    EQUALS          reduce using rule 17 (declarator -> direct_declarator .)
    COMMA           reduce using rule 17 (declarator -> direct_declarator .)
    SEMI            reduce using rule 17 (declarator -> direct_declarator .)
    RPAREN          reduce using rule 17 (declarator -> direct_declarator .)
    LBRACKET        shift and go to state 26
    LPAREN          shift and go to state 27

  ! LBRACKET        [ reduce using rule 17 (declarator -> direct_declarator .) ]
  ! LPAREN          [ reduce using rule 17 (declarator -> direct_declarator .) ]


state 9

    (18) declarator -> pointer . direct_declarator
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (10) identifier -> . ID
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer

    ID              shift and go to state 16
    TIMES           shift and go to state 15

    pointer                        shift and go to state 9
    direct_declarator              shift and go to state 28
    identifier                     shift and go to state 14
    declarator                     shift and go to state 29

state 10

    (11) type_specifier -> VOID .

    TIMES           reduce using rule 11 (type_specifier -> VOID .)
    ID              reduce using rule 11 (type_specifier -> VOID .)
    SEMI            reduce using rule 11 (type_specifier -> VOID .)
    RPAREN          reduce using rule 11 (type_specifier -> VOID .)


state 11

    (12) type_specifier -> CHAR .

    TIMES           reduce using rule 12 (type_specifier -> CHAR .)
    ID              reduce using rule 12 (type_specifier -> CHAR .)
    SEMI            reduce using rule 12 (type_specifier -> CHAR .)
    RPAREN          reduce using rule 12 (type_specifier -> CHAR .)


state 12

    (13) type_specifier -> INT .

    TIMES           reduce using rule 13 (type_specifier -> INT .)
    ID              reduce using rule 13 (type_specifier -> INT .)
    SEMI            reduce using rule 13 (type_specifier -> INT .)
    RPAREN          reduce using rule 13 (type_specifier -> INT .)


state 13

    (14) type_specifier -> FLOAT .

    TIMES           reduce using rule 14 (type_specifier -> FLOAT .)
    ID              reduce using rule 14 (type_specifier -> FLOAT .)
    SEMI            reduce using rule 14 (type_specifier -> FLOAT .)
    RPAREN          reduce using rule 14 (type_specifier -> FLOAT .)


state 14

    (19) direct_declarator -> identifier .

    VOID            reduce using rule 19 (direct_declarator -> identifier .)
    CHAR            reduce using rule 19 (direct_declarator -> identifier .)
    INT             reduce using rule 19 (direct_declarator -> identifier .)
    FLOAT           reduce using rule 19 (direct_declarator -> identifier .)
    LBRACKET        reduce using rule 19 (direct_declarator -> identifier .)
    LPAREN          reduce using rule 19 (direct_declarator -> identifier .)
    EQUALS          reduce using rule 19 (direct_declarator -> identifier .)
    COMMA           reduce using rule 19 (direct_declarator -> identifier .)
    SEMI            reduce using rule 19 (direct_declarator -> identifier .)
    RPAREN          reduce using rule 19 (direct_declarator -> identifier .)


state 15

    (15) pointer -> TIMES .
    (16) pointer -> TIMES . pointer
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer

    ID              reduce using rule 15 (pointer -> TIMES .)
    TIMES           reduce using rule 15 (pointer -> TIMES .)

  ! TIMES           [ shift and go to state 15 ]

    pointer                        shift and go to state 30

state 16

    (10) identifier -> ID .

    VOID            reduce using rule 10 (identifier -> ID .)
    CHAR            reduce using rule 10 (identifier -> ID .)
    INT             reduce using rule 10 (identifier -> ID .)
    FLOAT           reduce using rule 10 (identifier -> ID .)
    LBRACKET        reduce using rule 10 (identifier -> ID .)
    LPAREN          reduce using rule 10 (identifier -> ID .)
    EQUALS          reduce using rule 10 (identifier -> ID .)
    COMMA           reduce using rule 10 (identifier -> ID .)
    SEMI            reduce using rule 10 (identifier -> ID .)
    RPAREN          reduce using rule 10 (identifier -> ID .)
    TIMES           reduce using rule 10 (identifier -> ID .)
    DIVIDE          reduce using rule 10 (identifier -> ID .)
    MOD             reduce using rule 10 (identifier -> ID .)
    PLUS            reduce using rule 10 (identifier -> ID .)
    MINUS           reduce using rule 10 (identifier -> ID .)
    LT              reduce using rule 10 (identifier -> ID .)
    LE              reduce using rule 10 (identifier -> ID .)
    GT              reduce using rule 10 (identifier -> ID .)
    GE              reduce using rule 10 (identifier -> ID .)
    EQ              reduce using rule 10 (identifier -> ID .)
    NQ              reduce using rule 10 (identifier -> ID .)
    AND             reduce using rule 10 (identifier -> ID .)
    OR              reduce using rule 10 (identifier -> ID .)
    RBRACKET        reduce using rule 10 (identifier -> ID .)
    INCREASE        reduce using rule 10 (identifier -> ID .)
    DECREASE        reduce using rule 10 (identifier -> ID .)
    EQTIMES         reduce using rule 10 (identifier -> ID .)
    EQDIV           reduce using rule 10 (identifier -> ID .)
    EQMOD           reduce using rule 10 (identifier -> ID .)
    EQPLUS          reduce using rule 10 (identifier -> ID .)
    EQMINUS         reduce using rule 10 (identifier -> ID .)


state 17

    (3) global_declaration_list -> global_declaration_list global_declaration .

    VOID            reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)
    CHAR            reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)
    INT             reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)
    FLOAT           reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)
    TIMES           reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)
    ID              reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)
    $end            reduce using rule 3 (global_declaration_list -> global_declaration_list global_declaration .)


state 18

    (6) function_definition -> declarator declaration_list . compound_statement
    (9) declaration_list -> declaration_list . declaration
    (93) compound_statement -> . declaration_list statement_list
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

    declaration_list               shift and go to state 31
    compound_statement             shift and go to state 32
    declaration                    shift and go to state 33
    type_specifier                 shift and go to state 20

state 19

    (8) declaration_list -> declaration .

    VOID            reduce using rule 8 (declaration_list -> declaration .)
    CHAR            reduce using rule 8 (declaration_list -> declaration .)
    INT             reduce using rule 8 (declaration_list -> declaration .)
    FLOAT           reduce using rule 8 (declaration_list -> declaration .)
    IF              reduce using rule 8 (declaration_list -> declaration .)
    WHILE           reduce using rule 8 (declaration_list -> declaration .)
    FOR             reduce using rule 8 (declaration_list -> declaration .)
    BREAK           reduce using rule 8 (declaration_list -> declaration .)
    RETURN          reduce using rule 8 (declaration_list -> declaration .)
    ASSERT          reduce using rule 8 (declaration_list -> declaration .)
    PRINT           reduce using rule 8 (declaration_list -> declaration .)
    READ            reduce using rule 8 (declaration_list -> declaration .)
    INCREASE        reduce using rule 8 (declaration_list -> declaration .)
    DECREASE        reduce using rule 8 (declaration_list -> declaration .)
    LPAREN          reduce using rule 8 (declaration_list -> declaration .)
    ADDRESS         reduce using rule 8 (declaration_list -> declaration .)
    TIMES           reduce using rule 8 (declaration_list -> declaration .)
    PLUS            reduce using rule 8 (declaration_list -> declaration .)
    MINUS           reduce using rule 8 (declaration_list -> declaration .)
    NOT             reduce using rule 8 (declaration_list -> declaration .)
    STRING          reduce using rule 8 (declaration_list -> declaration .)
    ID              reduce using rule 8 (declaration_list -> declaration .)
    INT_CONST       reduce using rule 8 (declaration_list -> declaration .)
    CHAR_CONST      reduce using rule 8 (declaration_list -> declaration .)
    FLOAT_CONST     reduce using rule 8 (declaration_list -> declaration .)
    SEMI            reduce using rule 8 (declaration_list -> declaration .)


state 20

    (81) declaration -> type_specifier . init_declarator_list_opt SEMI
    (82) init_declarator_list_opt -> . init_declarator_list
    (83) init_declarator_list_opt -> . empty
    (84) init_declarator_list -> . init_declarator
    (85) init_declarator_list -> . init_declarator_list COMMA init_declarator
    (117) empty -> .
    (86) init_declarator -> . declarator
    (87) init_declarator -> . declarator EQUALS initializer
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer
    (10) identifier -> . ID

    SEMI            reduce using rule 117 (empty -> .)
    TIMES           shift and go to state 15
    ID              shift and go to state 16

    init_declarator_list_opt       shift and go to state 22
    init_declarator_list           shift and go to state 23
    empty                          shift and go to state 24
    init_declarator                shift and go to state 25
    declarator                     shift and go to state 34
    direct_declarator              shift and go to state 8
    pointer                        shift and go to state 9
    identifier                     shift and go to state 14

state 21

    (7) function_definition -> type_specifier declarator . declaration_list compound_statement
    (20) direct_declarator -> declarator .
    (86) init_declarator -> declarator .
    (87) init_declarator -> declarator . EQUALS initializer
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

  ! reduce/reduce conflict for COMMA resolved using rule 20 (direct_declarator -> declarator .)
  ! reduce/reduce conflict for SEMI resolved using rule 20 (direct_declarator -> declarator .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    LBRACKET        reduce using rule 20 (direct_declarator -> declarator .)
    LPAREN          reduce using rule 20 (direct_declarator -> declarator .)
    COMMA           reduce using rule 20 (direct_declarator -> declarator .)
    SEMI            reduce using rule 20 (direct_declarator -> declarator .)
    EQUALS          shift and go to state 36
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

  ! EQUALS          [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! VOID            [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! CHAR            [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! INT             [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! FLOAT           [ reduce using rule 20 (direct_declarator -> declarator .) ]
  ! COMMA           [ reduce using rule 86 (init_declarator -> declarator .) ]
  ! SEMI            [ reduce using rule 86 (init_declarator -> declarator .) ]

    type_specifier                 shift and go to state 20
    declaration_list               shift and go to state 35
    declaration                    shift and go to state 19

state 22

    (81) declaration -> type_specifier init_declarator_list_opt . SEMI

    SEMI            shift and go to state 37


state 23

    (82) init_declarator_list_opt -> init_declarator_list .
    (85) init_declarator_list -> init_declarator_list . COMMA init_declarator

    SEMI            reduce using rule 82 (init_declarator_list_opt -> init_declarator_list .)
    COMMA           shift and go to state 38


state 24

    (83) init_declarator_list_opt -> empty .

    SEMI            reduce using rule 83 (init_declarator_list_opt -> empty .)


state 25

    (84) init_declarator_list -> init_declarator .

    COMMA           reduce using rule 84 (init_declarator_list -> init_declarator .)
    SEMI            reduce using rule 84 (init_declarator_list -> init_declarator .)


state 26

    (21) direct_declarator -> direct_declarator LBRACKET . constant_expression_opt RBRACKET
    (24) constant_expression_opt -> . constant_expression
    (25) constant_expression_opt -> . empty
    (26) constant_expression -> . binary_expression
    (117) empty -> .
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    RBRACKET        reduce using rule 117 (empty -> .)
    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    constant_expression_opt        shift and go to state 39
    constant_expression            shift and go to state 40
    empty                          shift and go to state 41
    binary_expression              shift and go to state 42
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 27

    (22) direct_declarator -> direct_declarator LPAREN . parameter_list RPAREN
    (23) direct_declarator -> direct_declarator LPAREN . identifier RPAREN
    (78) parameter_list -> . parameter_declaration
    (79) parameter_list -> . parameter_list COMMA parameter_declaration
    (10) identifier -> . ID
    (80) parameter_declaration -> . type_specifier declarator
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

    ID              shift and go to state 16
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

    parameter_list                 shift and go to state 64
    identifier                     shift and go to state 65
    parameter_declaration          shift and go to state 66
    type_specifier                 shift and go to state 67

state 28

    (18) declarator -> pointer direct_declarator .
    (21) direct_declarator -> direct_declarator . LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> direct_declarator . LPAREN parameter_list RPAREN
    (23) direct_declarator -> direct_declarator . LPAREN identifier RPAREN
    (17) declarator -> direct_declarator .

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for CHAR resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for INT resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for EQUALS resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for COMMA resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for SEMI resolved using rule 17 (declarator -> direct_declarator .)
  ! reduce/reduce conflict for RPAREN resolved using rule 17 (declarator -> direct_declarator .)
    LBRACKET        shift and go to state 26
    LPAREN          shift and go to state 27
    VOID            reduce using rule 17 (declarator -> direct_declarator .)
    CHAR            reduce using rule 17 (declarator -> direct_declarator .)
    INT             reduce using rule 17 (declarator -> direct_declarator .)
    FLOAT           reduce using rule 17 (declarator -> direct_declarator .)
    EQUALS          reduce using rule 17 (declarator -> direct_declarator .)
    COMMA           reduce using rule 17 (declarator -> direct_declarator .)
    SEMI            reduce using rule 17 (declarator -> direct_declarator .)
    RPAREN          reduce using rule 17 (declarator -> direct_declarator .)

  ! VOID            [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! CHAR            [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! INT             [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! FLOAT           [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! LBRACKET        [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! LPAREN          [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! EQUALS          [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! COMMA           [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! SEMI            [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! RPAREN          [ reduce using rule 18 (declarator -> pointer direct_declarator .) ]
  ! LBRACKET        [ reduce using rule 17 (declarator -> direct_declarator .) ]
  ! LPAREN          [ reduce using rule 17 (declarator -> direct_declarator .) ]


state 29

    (20) direct_declarator -> declarator .

    LBRACKET        reduce using rule 20 (direct_declarator -> declarator .)
    LPAREN          reduce using rule 20 (direct_declarator -> declarator .)
    VOID            reduce using rule 20 (direct_declarator -> declarator .)
    CHAR            reduce using rule 20 (direct_declarator -> declarator .)
    INT             reduce using rule 20 (direct_declarator -> declarator .)
    FLOAT           reduce using rule 20 (direct_declarator -> declarator .)
    EQUALS          reduce using rule 20 (direct_declarator -> declarator .)
    COMMA           reduce using rule 20 (direct_declarator -> declarator .)
    SEMI            reduce using rule 20 (direct_declarator -> declarator .)
    RPAREN          reduce using rule 20 (direct_declarator -> declarator .)


state 30

    (16) pointer -> TIMES pointer .

    ID              reduce using rule 16 (pointer -> TIMES pointer .)
    TIMES           reduce using rule 16 (pointer -> TIMES pointer .)


state 31

    (93) compound_statement -> declaration_list . statement_list
    (9) declaration_list -> declaration_list . declaration
    (94) statement_list -> . statement
    (95) statement_list -> . statement_list statement
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    SEMI            reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    declaration_list               shift and go to state 31
    statement_list                 shift and go to state 68
    declaration                    shift and go to state 33
    statement                      shift and go to state 69
    type_specifier                 shift and go to state 20
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    expression_opt                 shift and go to state 78
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 32

    (6) function_definition -> declarator declaration_list compound_statement .

    VOID            reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)
    CHAR            reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)
    INT             reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)
    FLOAT           reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)
    TIMES           reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)
    ID              reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)
    $end            reduce using rule 6 (function_definition -> declarator declaration_list compound_statement .)


state 33

    (9) declaration_list -> declaration_list declaration .
    (8) declaration_list -> declaration .

  ! reduce/reduce conflict for VOID resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for CHAR resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for INT resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for FLOAT resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for IF resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for WHILE resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for FOR resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for BREAK resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for RETURN resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for ASSERT resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for PRINT resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for READ resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for INCREASE resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for DECREASE resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for LPAREN resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for ADDRESS resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for TIMES resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for PLUS resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for MINUS resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for NOT resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for STRING resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for ID resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for INT_CONST resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for CHAR_CONST resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 8 (declaration_list -> declaration .)
  ! reduce/reduce conflict for SEMI resolved using rule 8 (declaration_list -> declaration .)
    VOID            reduce using rule 8 (declaration_list -> declaration .)
    CHAR            reduce using rule 8 (declaration_list -> declaration .)
    INT             reduce using rule 8 (declaration_list -> declaration .)
    FLOAT           reduce using rule 8 (declaration_list -> declaration .)
    IF              reduce using rule 8 (declaration_list -> declaration .)
    WHILE           reduce using rule 8 (declaration_list -> declaration .)
    FOR             reduce using rule 8 (declaration_list -> declaration .)
    BREAK           reduce using rule 8 (declaration_list -> declaration .)
    RETURN          reduce using rule 8 (declaration_list -> declaration .)
    ASSERT          reduce using rule 8 (declaration_list -> declaration .)
    PRINT           reduce using rule 8 (declaration_list -> declaration .)
    READ            reduce using rule 8 (declaration_list -> declaration .)
    INCREASE        reduce using rule 8 (declaration_list -> declaration .)
    DECREASE        reduce using rule 8 (declaration_list -> declaration .)
    LPAREN          reduce using rule 8 (declaration_list -> declaration .)
    ADDRESS         reduce using rule 8 (declaration_list -> declaration .)
    TIMES           reduce using rule 8 (declaration_list -> declaration .)
    PLUS            reduce using rule 8 (declaration_list -> declaration .)
    MINUS           reduce using rule 8 (declaration_list -> declaration .)
    NOT             reduce using rule 8 (declaration_list -> declaration .)
    STRING          reduce using rule 8 (declaration_list -> declaration .)
    ID              reduce using rule 8 (declaration_list -> declaration .)
    INT_CONST       reduce using rule 8 (declaration_list -> declaration .)
    CHAR_CONST      reduce using rule 8 (declaration_list -> declaration .)
    FLOAT_CONST     reduce using rule 8 (declaration_list -> declaration .)
    SEMI            reduce using rule 8 (declaration_list -> declaration .)

  ! VOID            [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! CHAR            [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! INT             [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! FLOAT           [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! IF              [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! WHILE           [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! FOR             [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! BREAK           [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! RETURN          [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! ASSERT          [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! PRINT           [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! READ            [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! INCREASE        [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! DECREASE        [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! LPAREN          [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! ADDRESS         [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! TIMES           [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! PLUS            [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! MINUS           [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! NOT             [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! STRING          [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! ID              [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! INT_CONST       [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! CHAR_CONST      [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! FLOAT_CONST     [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]
  ! SEMI            [ reduce using rule 9 (declaration_list -> declaration_list declaration .) ]


state 34

    (86) init_declarator -> declarator .
    (87) init_declarator -> declarator . EQUALS initializer
    (20) direct_declarator -> declarator .

  ! shift/reduce conflict for EQUALS resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 20 (direct_declarator -> declarator .)
  ! reduce/reduce conflict for SEMI resolved using rule 20 (direct_declarator -> declarator .)
    EQUALS          shift and go to state 36
    COMMA           reduce using rule 20 (direct_declarator -> declarator .)
    SEMI            reduce using rule 20 (direct_declarator -> declarator .)
    LBRACKET        reduce using rule 20 (direct_declarator -> declarator .)
    LPAREN          reduce using rule 20 (direct_declarator -> declarator .)

  ! COMMA           [ reduce using rule 86 (init_declarator -> declarator .) ]
  ! SEMI            [ reduce using rule 86 (init_declarator -> declarator .) ]
  ! EQUALS          [ reduce using rule 20 (direct_declarator -> declarator .) ]


state 35

    (7) function_definition -> type_specifier declarator declaration_list . compound_statement
    (9) declaration_list -> declaration_list . declaration
    (93) compound_statement -> . declaration_list statement_list
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

    type_specifier                 shift and go to state 20
    declaration_list               shift and go to state 31
    compound_statement             shift and go to state 91
    declaration                    shift and go to state 33

state 36

    (87) init_declarator -> declarator EQUALS . initializer
    (88) initializer -> . assignment_expression
    (89) initializer -> . initializer_list
    (90) initializer -> . initializer_list COMMA
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (91) initializer_list -> . initializer
    (92) initializer_list -> . initializer_list COMMA initializer
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    initializer                    shift and go to state 92
    assignment_expression          shift and go to state 93
    initializer_list               shift and go to state 94
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 37

    (81) declaration -> type_specifier init_declarator_list_opt SEMI .

    VOID            reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    CHAR            reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    INT             reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    FLOAT           reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    TIMES           reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    ID              reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    $end            reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    IF              reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    WHILE           reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    FOR             reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    BREAK           reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    RETURN          reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    ASSERT          reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    PRINT           reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    READ            reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    INCREASE        reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    DECREASE        reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    LPAREN          reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    ADDRESS         reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    PLUS            reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    MINUS           reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    NOT             reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    STRING          reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    INT_CONST       reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    CHAR_CONST      reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    FLOAT_CONST     reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)
    SEMI            reduce using rule 81 (declaration -> type_specifier init_declarator_list_opt SEMI .)


state 38

    (85) init_declarator_list -> init_declarator_list COMMA . init_declarator
    (86) init_declarator -> . declarator
    (87) init_declarator -> . declarator EQUALS initializer
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer
    (10) identifier -> . ID

    TIMES           shift and go to state 15
    ID              shift and go to state 16

    init_declarator                shift and go to state 95
    declarator                     shift and go to state 34
    direct_declarator              shift and go to state 8
    pointer                        shift and go to state 9
    identifier                     shift and go to state 14

state 39

    (21) direct_declarator -> direct_declarator LBRACKET constant_expression_opt . RBRACKET

    RBRACKET        shift and go to state 96


state 40

    (24) constant_expression_opt -> constant_expression .

    RBRACKET        reduce using rule 24 (constant_expression_opt -> constant_expression .)


state 41

    (25) constant_expression_opt -> empty .

    RBRACKET        reduce using rule 25 (constant_expression_opt -> empty .)


state 42

    (26) constant_expression -> binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 26 (constant_expression -> binary_expression .)
    RBRACKET        reduce using rule 26 (constant_expression -> binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109
    COMMA           reduce using rule 65 (assignment_expression -> binary_expression .)
    LBRACKET        reduce using rule 65 (assignment_expression -> binary_expression .)
    LPAREN          reduce using rule 65 (assignment_expression -> binary_expression .)
    INCREASE        reduce using rule 65 (assignment_expression -> binary_expression .)
    DECREASE        reduce using rule 65 (assignment_expression -> binary_expression .)
    EQUALS          reduce using rule 65 (assignment_expression -> binary_expression .)
    EQTIMES         reduce using rule 65 (assignment_expression -> binary_expression .)
    EQDIV           reduce using rule 65 (assignment_expression -> binary_expression .)
    EQMOD           reduce using rule 65 (assignment_expression -> binary_expression .)
    EQPLUS          reduce using rule 65 (assignment_expression -> binary_expression .)
    EQMINUS         reduce using rule 65 (assignment_expression -> binary_expression .)

  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 43

    (27) binary_expression -> cast_expression .

    TIMES           reduce using rule 27 (binary_expression -> cast_expression .)
    DIVIDE          reduce using rule 27 (binary_expression -> cast_expression .)
    MOD             reduce using rule 27 (binary_expression -> cast_expression .)
    PLUS            reduce using rule 27 (binary_expression -> cast_expression .)
    MINUS           reduce using rule 27 (binary_expression -> cast_expression .)
    LT              reduce using rule 27 (binary_expression -> cast_expression .)
    LE              reduce using rule 27 (binary_expression -> cast_expression .)
    GT              reduce using rule 27 (binary_expression -> cast_expression .)
    GE              reduce using rule 27 (binary_expression -> cast_expression .)
    EQ              reduce using rule 27 (binary_expression -> cast_expression .)
    NQ              reduce using rule 27 (binary_expression -> cast_expression .)
    AND             reduce using rule 27 (binary_expression -> cast_expression .)
    OR              reduce using rule 27 (binary_expression -> cast_expression .)
    RBRACKET        reduce using rule 27 (binary_expression -> cast_expression .)
    COMMA           reduce using rule 27 (binary_expression -> cast_expression .)
    LBRACKET        reduce using rule 27 (binary_expression -> cast_expression .)
    LPAREN          reduce using rule 27 (binary_expression -> cast_expression .)
    INCREASE        reduce using rule 27 (binary_expression -> cast_expression .)
    DECREASE        reduce using rule 27 (binary_expression -> cast_expression .)
    EQUALS          reduce using rule 27 (binary_expression -> cast_expression .)
    EQTIMES         reduce using rule 27 (binary_expression -> cast_expression .)
    EQDIV           reduce using rule 27 (binary_expression -> cast_expression .)
    EQMOD           reduce using rule 27 (binary_expression -> cast_expression .)
    EQPLUS          reduce using rule 27 (binary_expression -> cast_expression .)
    EQMINUS         reduce using rule 27 (binary_expression -> cast_expression .)
    SEMI            reduce using rule 27 (binary_expression -> cast_expression .)
    RPAREN          reduce using rule 27 (binary_expression -> cast_expression .)


state 44

    (74) unary_operator -> TIMES .

    LPAREN          reduce using rule 74 (unary_operator -> TIMES .)
    INCREASE        reduce using rule 74 (unary_operator -> TIMES .)
    DECREASE        reduce using rule 74 (unary_operator -> TIMES .)
    ADDRESS         reduce using rule 74 (unary_operator -> TIMES .)
    TIMES           reduce using rule 74 (unary_operator -> TIMES .)
    PLUS            reduce using rule 74 (unary_operator -> TIMES .)
    MINUS           reduce using rule 74 (unary_operator -> TIMES .)
    NOT             reduce using rule 74 (unary_operator -> TIMES .)
    STRING          reduce using rule 74 (unary_operator -> TIMES .)
    ID              reduce using rule 74 (unary_operator -> TIMES .)
    INT_CONST       reduce using rule 74 (unary_operator -> TIMES .)
    CHAR_CONST      reduce using rule 74 (unary_operator -> TIMES .)
    FLOAT_CONST     reduce using rule 74 (unary_operator -> TIMES .)


state 45

    (75) unary_operator -> PLUS .

    LPAREN          reduce using rule 75 (unary_operator -> PLUS .)
    INCREASE        reduce using rule 75 (unary_operator -> PLUS .)
    DECREASE        reduce using rule 75 (unary_operator -> PLUS .)
    ADDRESS         reduce using rule 75 (unary_operator -> PLUS .)
    TIMES           reduce using rule 75 (unary_operator -> PLUS .)
    PLUS            reduce using rule 75 (unary_operator -> PLUS .)
    MINUS           reduce using rule 75 (unary_operator -> PLUS .)
    NOT             reduce using rule 75 (unary_operator -> PLUS .)
    STRING          reduce using rule 75 (unary_operator -> PLUS .)
    ID              reduce using rule 75 (unary_operator -> PLUS .)
    INT_CONST       reduce using rule 75 (unary_operator -> PLUS .)
    CHAR_CONST      reduce using rule 75 (unary_operator -> PLUS .)
    FLOAT_CONST     reduce using rule 75 (unary_operator -> PLUS .)


state 46

    (76) unary_operator -> MINUS .

    LPAREN          reduce using rule 76 (unary_operator -> MINUS .)
    INCREASE        reduce using rule 76 (unary_operator -> MINUS .)
    DECREASE        reduce using rule 76 (unary_operator -> MINUS .)
    ADDRESS         reduce using rule 76 (unary_operator -> MINUS .)
    TIMES           reduce using rule 76 (unary_operator -> MINUS .)
    PLUS            reduce using rule 76 (unary_operator -> MINUS .)
    MINUS           reduce using rule 76 (unary_operator -> MINUS .)
    NOT             reduce using rule 76 (unary_operator -> MINUS .)
    STRING          reduce using rule 76 (unary_operator -> MINUS .)
    ID              reduce using rule 76 (unary_operator -> MINUS .)
    INT_CONST       reduce using rule 76 (unary_operator -> MINUS .)
    CHAR_CONST      reduce using rule 76 (unary_operator -> MINUS .)
    FLOAT_CONST     reduce using rule 76 (unary_operator -> MINUS .)


state 47

    (41) cast_expression -> unary_expression .
    (66) assignment_expression -> unary_expression . assignment_operator assignment_expression
    (67) assignment_operator -> . EQUALS
    (68) assignment_operator -> . EQTIMES
    (69) assignment_operator -> . EQDIV
    (70) assignment_operator -> . EQMOD
    (71) assignment_operator -> . EQPLUS
    (72) assignment_operator -> . EQMINUS

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for EQTIMES resolved as shift
  ! shift/reduce conflict for EQDIV resolved as shift
  ! shift/reduce conflict for EQMOD resolved as shift
  ! shift/reduce conflict for EQPLUS resolved as shift
  ! shift/reduce conflict for EQMINUS resolved as shift
    TIMES           reduce using rule 41 (cast_expression -> unary_expression .)
    DIVIDE          reduce using rule 41 (cast_expression -> unary_expression .)
    MOD             reduce using rule 41 (cast_expression -> unary_expression .)
    PLUS            reduce using rule 41 (cast_expression -> unary_expression .)
    MINUS           reduce using rule 41 (cast_expression -> unary_expression .)
    LT              reduce using rule 41 (cast_expression -> unary_expression .)
    LE              reduce using rule 41 (cast_expression -> unary_expression .)
    GT              reduce using rule 41 (cast_expression -> unary_expression .)
    GE              reduce using rule 41 (cast_expression -> unary_expression .)
    EQ              reduce using rule 41 (cast_expression -> unary_expression .)
    NQ              reduce using rule 41 (cast_expression -> unary_expression .)
    AND             reduce using rule 41 (cast_expression -> unary_expression .)
    OR              reduce using rule 41 (cast_expression -> unary_expression .)
    RBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    COMMA           reduce using rule 41 (cast_expression -> unary_expression .)
    LBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    LPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    INCREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    DECREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    SEMI            reduce using rule 41 (cast_expression -> unary_expression .)
    RPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    EQUALS          shift and go to state 111
    EQTIMES         shift and go to state 112
    EQDIV           shift and go to state 113
    EQMOD           shift and go to state 114
    EQPLUS          shift and go to state 115
    EQMINUS         shift and go to state 116

  ! EQUALS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQTIMES         [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQDIV           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMOD           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQPLUS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMINUS         [ reduce using rule 41 (cast_expression -> unary_expression .) ]

    assignment_operator            shift and go to state 110

state 48

    (42) cast_expression -> LPAREN . type_specifier RPAREN cast_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

    type_specifier                 shift and go to state 117

state 49

    (43) unary_expression -> postfix_expression .
    (48) postfix_expression -> postfix_expression . LBRACKET expression RBRACKET
    (49) postfix_expression -> postfix_expression . LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> postfix_expression . INCREASE
    (51) postfix_expression -> postfix_expression . DECREASE

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INCREASE resolved as shift
  ! shift/reduce conflict for DECREASE resolved as shift
    TIMES           reduce using rule 43 (unary_expression -> postfix_expression .)
    DIVIDE          reduce using rule 43 (unary_expression -> postfix_expression .)
    MOD             reduce using rule 43 (unary_expression -> postfix_expression .)
    PLUS            reduce using rule 43 (unary_expression -> postfix_expression .)
    MINUS           reduce using rule 43 (unary_expression -> postfix_expression .)
    LT              reduce using rule 43 (unary_expression -> postfix_expression .)
    LE              reduce using rule 43 (unary_expression -> postfix_expression .)
    GT              reduce using rule 43 (unary_expression -> postfix_expression .)
    GE              reduce using rule 43 (unary_expression -> postfix_expression .)
    EQ              reduce using rule 43 (unary_expression -> postfix_expression .)
    NQ              reduce using rule 43 (unary_expression -> postfix_expression .)
    AND             reduce using rule 43 (unary_expression -> postfix_expression .)
    OR              reduce using rule 43 (unary_expression -> postfix_expression .)
    RBRACKET        reduce using rule 43 (unary_expression -> postfix_expression .)
    COMMA           reduce using rule 43 (unary_expression -> postfix_expression .)
    EQUALS          reduce using rule 43 (unary_expression -> postfix_expression .)
    EQTIMES         reduce using rule 43 (unary_expression -> postfix_expression .)
    EQDIV           reduce using rule 43 (unary_expression -> postfix_expression .)
    EQMOD           reduce using rule 43 (unary_expression -> postfix_expression .)
    EQPLUS          reduce using rule 43 (unary_expression -> postfix_expression .)
    EQMINUS         reduce using rule 43 (unary_expression -> postfix_expression .)
    SEMI            reduce using rule 43 (unary_expression -> postfix_expression .)
    RPAREN          reduce using rule 43 (unary_expression -> postfix_expression .)
    LBRACKET        shift and go to state 118
    LPAREN          shift and go to state 119
    INCREASE        shift and go to state 120
    DECREASE        shift and go to state 121

  ! LBRACKET        [ reduce using rule 43 (unary_expression -> postfix_expression .) ]
  ! LPAREN          [ reduce using rule 43 (unary_expression -> postfix_expression .) ]
  ! INCREASE        [ reduce using rule 43 (unary_expression -> postfix_expression .) ]
  ! DECREASE        [ reduce using rule 43 (unary_expression -> postfix_expression .) ]


state 50

    (44) unary_expression -> INCREASE . unary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    LPAREN          shift and go to state 48

    unary_expression               shift and go to state 122
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    cast_expression                shift and go to state 43
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89

state 51

    (45) unary_expression -> DECREASE . unary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    LPAREN          shift and go to state 48

    unary_expression               shift and go to state 123
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    cast_expression                shift and go to state 43
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89

state 52

    (46) unary_expression -> unary_operator . cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    unary_operator                 shift and go to state 52
    cast_expression                shift and go to state 124
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89

state 53

    (47) postfix_expression -> primary_expression .

    TIMES           reduce using rule 47 (postfix_expression -> primary_expression .)
    DIVIDE          reduce using rule 47 (postfix_expression -> primary_expression .)
    MOD             reduce using rule 47 (postfix_expression -> primary_expression .)
    PLUS            reduce using rule 47 (postfix_expression -> primary_expression .)
    MINUS           reduce using rule 47 (postfix_expression -> primary_expression .)
    LT              reduce using rule 47 (postfix_expression -> primary_expression .)
    LE              reduce using rule 47 (postfix_expression -> primary_expression .)
    GT              reduce using rule 47 (postfix_expression -> primary_expression .)
    GE              reduce using rule 47 (postfix_expression -> primary_expression .)
    EQ              reduce using rule 47 (postfix_expression -> primary_expression .)
    NQ              reduce using rule 47 (postfix_expression -> primary_expression .)
    AND             reduce using rule 47 (postfix_expression -> primary_expression .)
    OR              reduce using rule 47 (postfix_expression -> primary_expression .)
    RBRACKET        reduce using rule 47 (postfix_expression -> primary_expression .)
    COMMA           reduce using rule 47 (postfix_expression -> primary_expression .)
    LBRACKET        reduce using rule 47 (postfix_expression -> primary_expression .)
    LPAREN          reduce using rule 47 (postfix_expression -> primary_expression .)
    INCREASE        reduce using rule 47 (postfix_expression -> primary_expression .)
    DECREASE        reduce using rule 47 (postfix_expression -> primary_expression .)
    EQUALS          reduce using rule 47 (postfix_expression -> primary_expression .)
    EQTIMES         reduce using rule 47 (postfix_expression -> primary_expression .)
    EQDIV           reduce using rule 47 (postfix_expression -> primary_expression .)
    EQMOD           reduce using rule 47 (postfix_expression -> primary_expression .)
    EQPLUS          reduce using rule 47 (postfix_expression -> primary_expression .)
    EQMINUS         reduce using rule 47 (postfix_expression -> primary_expression .)
    SEMI            reduce using rule 47 (postfix_expression -> primary_expression .)
    RPAREN          reduce using rule 47 (postfix_expression -> primary_expression .)


state 54

    (57) primary_expression -> expression .
    (62) expression -> expression . COMMA assignment_expression

  ! shift/reduce conflict for COMMA resolved as shift
    TIMES           reduce using rule 57 (primary_expression -> expression .)
    DIVIDE          reduce using rule 57 (primary_expression -> expression .)
    MOD             reduce using rule 57 (primary_expression -> expression .)
    PLUS            reduce using rule 57 (primary_expression -> expression .)
    MINUS           reduce using rule 57 (primary_expression -> expression .)
    LT              reduce using rule 57 (primary_expression -> expression .)
    LE              reduce using rule 57 (primary_expression -> expression .)
    GT              reduce using rule 57 (primary_expression -> expression .)
    GE              reduce using rule 57 (primary_expression -> expression .)
    EQ              reduce using rule 57 (primary_expression -> expression .)
    NQ              reduce using rule 57 (primary_expression -> expression .)
    AND             reduce using rule 57 (primary_expression -> expression .)
    OR              reduce using rule 57 (primary_expression -> expression .)
    RBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LPAREN          reduce using rule 57 (primary_expression -> expression .)
    INCREASE        reduce using rule 57 (primary_expression -> expression .)
    DECREASE        reduce using rule 57 (primary_expression -> expression .)
    EQUALS          reduce using rule 57 (primary_expression -> expression .)
    EQTIMES         reduce using rule 57 (primary_expression -> expression .)
    EQDIV           reduce using rule 57 (primary_expression -> expression .)
    EQMOD           reduce using rule 57 (primary_expression -> expression .)
    EQPLUS          reduce using rule 57 (primary_expression -> expression .)
    EQMINUS         reduce using rule 57 (primary_expression -> expression .)
    SEMI            reduce using rule 57 (primary_expression -> expression .)
    RPAREN          reduce using rule 57 (primary_expression -> expression .)
    COMMA           shift and go to state 125

  ! COMMA           [ reduce using rule 57 (primary_expression -> expression .) ]


state 55

    (73) unary_operator -> ADDRESS .

    LPAREN          reduce using rule 73 (unary_operator -> ADDRESS .)
    INCREASE        reduce using rule 73 (unary_operator -> ADDRESS .)
    DECREASE        reduce using rule 73 (unary_operator -> ADDRESS .)
    ADDRESS         reduce using rule 73 (unary_operator -> ADDRESS .)
    TIMES           reduce using rule 73 (unary_operator -> ADDRESS .)
    PLUS            reduce using rule 73 (unary_operator -> ADDRESS .)
    MINUS           reduce using rule 73 (unary_operator -> ADDRESS .)
    NOT             reduce using rule 73 (unary_operator -> ADDRESS .)
    STRING          reduce using rule 73 (unary_operator -> ADDRESS .)
    ID              reduce using rule 73 (unary_operator -> ADDRESS .)
    INT_CONST       reduce using rule 73 (unary_operator -> ADDRESS .)
    CHAR_CONST      reduce using rule 73 (unary_operator -> ADDRESS .)
    FLOAT_CONST     reduce using rule 73 (unary_operator -> ADDRESS .)


state 56

    (77) unary_operator -> NOT .

    LPAREN          reduce using rule 77 (unary_operator -> NOT .)
    INCREASE        reduce using rule 77 (unary_operator -> NOT .)
    DECREASE        reduce using rule 77 (unary_operator -> NOT .)
    ADDRESS         reduce using rule 77 (unary_operator -> NOT .)
    TIMES           reduce using rule 77 (unary_operator -> NOT .)
    PLUS            reduce using rule 77 (unary_operator -> NOT .)
    MINUS           reduce using rule 77 (unary_operator -> NOT .)
    NOT             reduce using rule 77 (unary_operator -> NOT .)
    STRING          reduce using rule 77 (unary_operator -> NOT .)
    ID              reduce using rule 77 (unary_operator -> NOT .)
    INT_CONST       reduce using rule 77 (unary_operator -> NOT .)
    CHAR_CONST      reduce using rule 77 (unary_operator -> NOT .)
    FLOAT_CONST     reduce using rule 77 (unary_operator -> NOT .)


state 57

    (54) primary_expression -> identifier .

    TIMES           reduce using rule 54 (primary_expression -> identifier .)
    DIVIDE          reduce using rule 54 (primary_expression -> identifier .)
    MOD             reduce using rule 54 (primary_expression -> identifier .)
    PLUS            reduce using rule 54 (primary_expression -> identifier .)
    MINUS           reduce using rule 54 (primary_expression -> identifier .)
    LT              reduce using rule 54 (primary_expression -> identifier .)
    LE              reduce using rule 54 (primary_expression -> identifier .)
    GT              reduce using rule 54 (primary_expression -> identifier .)
    GE              reduce using rule 54 (primary_expression -> identifier .)
    EQ              reduce using rule 54 (primary_expression -> identifier .)
    NQ              reduce using rule 54 (primary_expression -> identifier .)
    AND             reduce using rule 54 (primary_expression -> identifier .)
    OR              reduce using rule 54 (primary_expression -> identifier .)
    RBRACKET        reduce using rule 54 (primary_expression -> identifier .)
    COMMA           reduce using rule 54 (primary_expression -> identifier .)
    LBRACKET        reduce using rule 54 (primary_expression -> identifier .)
    LPAREN          reduce using rule 54 (primary_expression -> identifier .)
    INCREASE        reduce using rule 54 (primary_expression -> identifier .)
    DECREASE        reduce using rule 54 (primary_expression -> identifier .)
    EQUALS          reduce using rule 54 (primary_expression -> identifier .)
    EQTIMES         reduce using rule 54 (primary_expression -> identifier .)
    EQDIV           reduce using rule 54 (primary_expression -> identifier .)
    EQMOD           reduce using rule 54 (primary_expression -> identifier .)
    EQPLUS          reduce using rule 54 (primary_expression -> identifier .)
    EQMINUS         reduce using rule 54 (primary_expression -> identifier .)
    SEMI            reduce using rule 54 (primary_expression -> identifier .)
    RPAREN          reduce using rule 54 (primary_expression -> identifier .)


state 58

    (55) primary_expression -> constant .

    TIMES           reduce using rule 55 (primary_expression -> constant .)
    DIVIDE          reduce using rule 55 (primary_expression -> constant .)
    MOD             reduce using rule 55 (primary_expression -> constant .)
    PLUS            reduce using rule 55 (primary_expression -> constant .)
    MINUS           reduce using rule 55 (primary_expression -> constant .)
    LT              reduce using rule 55 (primary_expression -> constant .)
    LE              reduce using rule 55 (primary_expression -> constant .)
    GT              reduce using rule 55 (primary_expression -> constant .)
    GE              reduce using rule 55 (primary_expression -> constant .)
    EQ              reduce using rule 55 (primary_expression -> constant .)
    NQ              reduce using rule 55 (primary_expression -> constant .)
    AND             reduce using rule 55 (primary_expression -> constant .)
    OR              reduce using rule 55 (primary_expression -> constant .)
    RBRACKET        reduce using rule 55 (primary_expression -> constant .)
    COMMA           reduce using rule 55 (primary_expression -> constant .)
    LBRACKET        reduce using rule 55 (primary_expression -> constant .)
    LPAREN          reduce using rule 55 (primary_expression -> constant .)
    INCREASE        reduce using rule 55 (primary_expression -> constant .)
    DECREASE        reduce using rule 55 (primary_expression -> constant .)
    EQUALS          reduce using rule 55 (primary_expression -> constant .)
    EQTIMES         reduce using rule 55 (primary_expression -> constant .)
    EQDIV           reduce using rule 55 (primary_expression -> constant .)
    EQMOD           reduce using rule 55 (primary_expression -> constant .)
    EQPLUS          reduce using rule 55 (primary_expression -> constant .)
    EQMINUS         reduce using rule 55 (primary_expression -> constant .)
    SEMI            reduce using rule 55 (primary_expression -> constant .)
    RPAREN          reduce using rule 55 (primary_expression -> constant .)


state 59

    (56) primary_expression -> STRING .

    TIMES           reduce using rule 56 (primary_expression -> STRING .)
    DIVIDE          reduce using rule 56 (primary_expression -> STRING .)
    MOD             reduce using rule 56 (primary_expression -> STRING .)
    PLUS            reduce using rule 56 (primary_expression -> STRING .)
    MINUS           reduce using rule 56 (primary_expression -> STRING .)
    LT              reduce using rule 56 (primary_expression -> STRING .)
    LE              reduce using rule 56 (primary_expression -> STRING .)
    GT              reduce using rule 56 (primary_expression -> STRING .)
    GE              reduce using rule 56 (primary_expression -> STRING .)
    EQ              reduce using rule 56 (primary_expression -> STRING .)
    NQ              reduce using rule 56 (primary_expression -> STRING .)
    AND             reduce using rule 56 (primary_expression -> STRING .)
    OR              reduce using rule 56 (primary_expression -> STRING .)
    RBRACKET        reduce using rule 56 (primary_expression -> STRING .)
    COMMA           reduce using rule 56 (primary_expression -> STRING .)
    LBRACKET        reduce using rule 56 (primary_expression -> STRING .)
    LPAREN          reduce using rule 56 (primary_expression -> STRING .)
    INCREASE        reduce using rule 56 (primary_expression -> STRING .)
    DECREASE        reduce using rule 56 (primary_expression -> STRING .)
    EQUALS          reduce using rule 56 (primary_expression -> STRING .)
    EQTIMES         reduce using rule 56 (primary_expression -> STRING .)
    EQDIV           reduce using rule 56 (primary_expression -> STRING .)
    EQMOD           reduce using rule 56 (primary_expression -> STRING .)
    EQPLUS          reduce using rule 56 (primary_expression -> STRING .)
    EQMINUS         reduce using rule 56 (primary_expression -> STRING .)
    SEMI            reduce using rule 56 (primary_expression -> STRING .)
    RPAREN          reduce using rule 56 (primary_expression -> STRING .)


state 60

    (58) constant -> INT_CONST .

    TIMES           reduce using rule 58 (constant -> INT_CONST .)
    DIVIDE          reduce using rule 58 (constant -> INT_CONST .)
    MOD             reduce using rule 58 (constant -> INT_CONST .)
    PLUS            reduce using rule 58 (constant -> INT_CONST .)
    MINUS           reduce using rule 58 (constant -> INT_CONST .)
    LT              reduce using rule 58 (constant -> INT_CONST .)
    LE              reduce using rule 58 (constant -> INT_CONST .)
    GT              reduce using rule 58 (constant -> INT_CONST .)
    GE              reduce using rule 58 (constant -> INT_CONST .)
    EQ              reduce using rule 58 (constant -> INT_CONST .)
    NQ              reduce using rule 58 (constant -> INT_CONST .)
    AND             reduce using rule 58 (constant -> INT_CONST .)
    OR              reduce using rule 58 (constant -> INT_CONST .)
    RBRACKET        reduce using rule 58 (constant -> INT_CONST .)
    COMMA           reduce using rule 58 (constant -> INT_CONST .)
    LBRACKET        reduce using rule 58 (constant -> INT_CONST .)
    LPAREN          reduce using rule 58 (constant -> INT_CONST .)
    INCREASE        reduce using rule 58 (constant -> INT_CONST .)
    DECREASE        reduce using rule 58 (constant -> INT_CONST .)
    EQUALS          reduce using rule 58 (constant -> INT_CONST .)
    EQTIMES         reduce using rule 58 (constant -> INT_CONST .)
    EQDIV           reduce using rule 58 (constant -> INT_CONST .)
    EQMOD           reduce using rule 58 (constant -> INT_CONST .)
    EQPLUS          reduce using rule 58 (constant -> INT_CONST .)
    EQMINUS         reduce using rule 58 (constant -> INT_CONST .)
    SEMI            reduce using rule 58 (constant -> INT_CONST .)
    RPAREN          reduce using rule 58 (constant -> INT_CONST .)


state 61

    (59) constant -> CHAR_CONST .

    TIMES           reduce using rule 59 (constant -> CHAR_CONST .)
    DIVIDE          reduce using rule 59 (constant -> CHAR_CONST .)
    MOD             reduce using rule 59 (constant -> CHAR_CONST .)
    PLUS            reduce using rule 59 (constant -> CHAR_CONST .)
    MINUS           reduce using rule 59 (constant -> CHAR_CONST .)
    LT              reduce using rule 59 (constant -> CHAR_CONST .)
    LE              reduce using rule 59 (constant -> CHAR_CONST .)
    GT              reduce using rule 59 (constant -> CHAR_CONST .)
    GE              reduce using rule 59 (constant -> CHAR_CONST .)
    EQ              reduce using rule 59 (constant -> CHAR_CONST .)
    NQ              reduce using rule 59 (constant -> CHAR_CONST .)
    AND             reduce using rule 59 (constant -> CHAR_CONST .)
    OR              reduce using rule 59 (constant -> CHAR_CONST .)
    RBRACKET        reduce using rule 59 (constant -> CHAR_CONST .)
    COMMA           reduce using rule 59 (constant -> CHAR_CONST .)
    LBRACKET        reduce using rule 59 (constant -> CHAR_CONST .)
    LPAREN          reduce using rule 59 (constant -> CHAR_CONST .)
    INCREASE        reduce using rule 59 (constant -> CHAR_CONST .)
    DECREASE        reduce using rule 59 (constant -> CHAR_CONST .)
    EQUALS          reduce using rule 59 (constant -> CHAR_CONST .)
    EQTIMES         reduce using rule 59 (constant -> CHAR_CONST .)
    EQDIV           reduce using rule 59 (constant -> CHAR_CONST .)
    EQMOD           reduce using rule 59 (constant -> CHAR_CONST .)
    EQPLUS          reduce using rule 59 (constant -> CHAR_CONST .)
    EQMINUS         reduce using rule 59 (constant -> CHAR_CONST .)
    SEMI            reduce using rule 59 (constant -> CHAR_CONST .)
    RPAREN          reduce using rule 59 (constant -> CHAR_CONST .)


state 62

    (60) constant -> FLOAT_CONST .

    TIMES           reduce using rule 60 (constant -> FLOAT_CONST .)
    DIVIDE          reduce using rule 60 (constant -> FLOAT_CONST .)
    MOD             reduce using rule 60 (constant -> FLOAT_CONST .)
    PLUS            reduce using rule 60 (constant -> FLOAT_CONST .)
    MINUS           reduce using rule 60 (constant -> FLOAT_CONST .)
    LT              reduce using rule 60 (constant -> FLOAT_CONST .)
    LE              reduce using rule 60 (constant -> FLOAT_CONST .)
    GT              reduce using rule 60 (constant -> FLOAT_CONST .)
    GE              reduce using rule 60 (constant -> FLOAT_CONST .)
    EQ              reduce using rule 60 (constant -> FLOAT_CONST .)
    NQ              reduce using rule 60 (constant -> FLOAT_CONST .)
    AND             reduce using rule 60 (constant -> FLOAT_CONST .)
    OR              reduce using rule 60 (constant -> FLOAT_CONST .)
    RBRACKET        reduce using rule 60 (constant -> FLOAT_CONST .)
    COMMA           reduce using rule 60 (constant -> FLOAT_CONST .)
    LBRACKET        reduce using rule 60 (constant -> FLOAT_CONST .)
    LPAREN          reduce using rule 60 (constant -> FLOAT_CONST .)
    INCREASE        reduce using rule 60 (constant -> FLOAT_CONST .)
    DECREASE        reduce using rule 60 (constant -> FLOAT_CONST .)
    EQUALS          reduce using rule 60 (constant -> FLOAT_CONST .)
    EQTIMES         reduce using rule 60 (constant -> FLOAT_CONST .)
    EQDIV           reduce using rule 60 (constant -> FLOAT_CONST .)
    EQMOD           reduce using rule 60 (constant -> FLOAT_CONST .)
    EQPLUS          reduce using rule 60 (constant -> FLOAT_CONST .)
    EQMINUS         reduce using rule 60 (constant -> FLOAT_CONST .)
    SEMI            reduce using rule 60 (constant -> FLOAT_CONST .)
    RPAREN          reduce using rule 60 (constant -> FLOAT_CONST .)


state 63

    (61) expression -> assignment_expression .

    TIMES           reduce using rule 61 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 61 (expression -> assignment_expression .)
    MOD             reduce using rule 61 (expression -> assignment_expression .)
    PLUS            reduce using rule 61 (expression -> assignment_expression .)
    MINUS           reduce using rule 61 (expression -> assignment_expression .)
    LT              reduce using rule 61 (expression -> assignment_expression .)
    LE              reduce using rule 61 (expression -> assignment_expression .)
    GT              reduce using rule 61 (expression -> assignment_expression .)
    GE              reduce using rule 61 (expression -> assignment_expression .)
    EQ              reduce using rule 61 (expression -> assignment_expression .)
    NQ              reduce using rule 61 (expression -> assignment_expression .)
    AND             reduce using rule 61 (expression -> assignment_expression .)
    OR              reduce using rule 61 (expression -> assignment_expression .)
    RBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    COMMA           reduce using rule 61 (expression -> assignment_expression .)
    LBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    LPAREN          reduce using rule 61 (expression -> assignment_expression .)
    INCREASE        reduce using rule 61 (expression -> assignment_expression .)
    DECREASE        reduce using rule 61 (expression -> assignment_expression .)
    EQUALS          reduce using rule 61 (expression -> assignment_expression .)
    EQTIMES         reduce using rule 61 (expression -> assignment_expression .)
    EQDIV           reduce using rule 61 (expression -> assignment_expression .)
    EQMOD           reduce using rule 61 (expression -> assignment_expression .)
    EQPLUS          reduce using rule 61 (expression -> assignment_expression .)
    EQMINUS         reduce using rule 61 (expression -> assignment_expression .)
    SEMI            reduce using rule 61 (expression -> assignment_expression .)
    RPAREN          reduce using rule 61 (expression -> assignment_expression .)


state 64

    (22) direct_declarator -> direct_declarator LPAREN parameter_list . RPAREN
    (79) parameter_list -> parameter_list . COMMA parameter_declaration

    RPAREN          shift and go to state 126
    COMMA           shift and go to state 127


state 65

    (23) direct_declarator -> direct_declarator LPAREN identifier . RPAREN

    RPAREN          shift and go to state 128


state 66

    (78) parameter_list -> parameter_declaration .

    RPAREN          reduce using rule 78 (parameter_list -> parameter_declaration .)
    COMMA           reduce using rule 78 (parameter_list -> parameter_declaration .)


state 67

    (80) parameter_declaration -> type_specifier . declarator
    (17) declarator -> . direct_declarator
    (18) declarator -> . pointer direct_declarator
    (19) direct_declarator -> . identifier
    (20) direct_declarator -> . declarator
    (21) direct_declarator -> . direct_declarator LBRACKET constant_expression_opt RBRACKET
    (22) direct_declarator -> . direct_declarator LPAREN parameter_list RPAREN
    (23) direct_declarator -> . direct_declarator LPAREN identifier RPAREN
    (15) pointer -> . TIMES
    (16) pointer -> . TIMES pointer
    (10) identifier -> . ID

    TIMES           shift and go to state 15
    ID              shift and go to state 16

    declarator                     shift and go to state 129
    direct_declarator              shift and go to state 8
    pointer                        shift and go to state 9
    identifier                     shift and go to state 14

state 68

    (93) compound_statement -> declaration_list statement_list .
    (95) statement_list -> statement_list . statement
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ASSERT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! reduce/reduce conflict for SEMI resolved using rule 93 (compound_statement -> declaration_list statement_list .)
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INCREASE resolved as shift
  ! shift/reduce conflict for DECREASE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ADDRESS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for CHAR_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
    $end            reduce using rule 93 (compound_statement -> declaration_list statement_list .)
    SEMI            reduce using rule 93 (compound_statement -> declaration_list statement_list .)
    ELSE            reduce using rule 93 (compound_statement -> declaration_list statement_list .)
    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

  ! VOID            [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! CHAR            [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! INT             [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! FLOAT           [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! TIMES           [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! ID              [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! IF              [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! WHILE           [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! FOR             [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! BREAK           [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! RETURN          [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! ASSERT          [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! PRINT           [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! READ            [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! INCREASE        [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! DECREASE        [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! LPAREN          [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! ADDRESS         [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! PLUS            [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! MINUS           [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! NOT             [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! STRING          [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! INT_CONST       [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! CHAR_CONST      [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! FLOAT_CONST     [ reduce using rule 93 (compound_statement -> declaration_list statement_list .) ]
  ! SEMI            [ reduce using rule 117 (empty -> .) ]

    declaration_list               shift and go to state 31
    statement                      shift and go to state 130
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    expression_opt                 shift and go to state 78
    expression                     shift and go to state 80
    declaration                    shift and go to state 19
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    type_specifier                 shift and go to state 20
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 69

    (94) statement_list -> statement .

    IF              reduce using rule 94 (statement_list -> statement .)
    WHILE           reduce using rule 94 (statement_list -> statement .)
    FOR             reduce using rule 94 (statement_list -> statement .)
    BREAK           reduce using rule 94 (statement_list -> statement .)
    RETURN          reduce using rule 94 (statement_list -> statement .)
    ASSERT          reduce using rule 94 (statement_list -> statement .)
    PRINT           reduce using rule 94 (statement_list -> statement .)
    READ            reduce using rule 94 (statement_list -> statement .)
    VOID            reduce using rule 94 (statement_list -> statement .)
    CHAR            reduce using rule 94 (statement_list -> statement .)
    INT             reduce using rule 94 (statement_list -> statement .)
    FLOAT           reduce using rule 94 (statement_list -> statement .)
    INCREASE        reduce using rule 94 (statement_list -> statement .)
    DECREASE        reduce using rule 94 (statement_list -> statement .)
    LPAREN          reduce using rule 94 (statement_list -> statement .)
    ADDRESS         reduce using rule 94 (statement_list -> statement .)
    TIMES           reduce using rule 94 (statement_list -> statement .)
    PLUS            reduce using rule 94 (statement_list -> statement .)
    MINUS           reduce using rule 94 (statement_list -> statement .)
    NOT             reduce using rule 94 (statement_list -> statement .)
    STRING          reduce using rule 94 (statement_list -> statement .)
    ID              reduce using rule 94 (statement_list -> statement .)
    INT_CONST       reduce using rule 94 (statement_list -> statement .)
    CHAR_CONST      reduce using rule 94 (statement_list -> statement .)
    FLOAT_CONST     reduce using rule 94 (statement_list -> statement .)
    SEMI            reduce using rule 94 (statement_list -> statement .)
    $end            reduce using rule 94 (statement_list -> statement .)
    ELSE            reduce using rule 94 (statement_list -> statement .)


state 70

    (96) statement -> expression_statement .

    IF              reduce using rule 96 (statement -> expression_statement .)
    WHILE           reduce using rule 96 (statement -> expression_statement .)
    FOR             reduce using rule 96 (statement -> expression_statement .)
    BREAK           reduce using rule 96 (statement -> expression_statement .)
    RETURN          reduce using rule 96 (statement -> expression_statement .)
    ASSERT          reduce using rule 96 (statement -> expression_statement .)
    PRINT           reduce using rule 96 (statement -> expression_statement .)
    READ            reduce using rule 96 (statement -> expression_statement .)
    VOID            reduce using rule 96 (statement -> expression_statement .)
    CHAR            reduce using rule 96 (statement -> expression_statement .)
    INT             reduce using rule 96 (statement -> expression_statement .)
    FLOAT           reduce using rule 96 (statement -> expression_statement .)
    INCREASE        reduce using rule 96 (statement -> expression_statement .)
    DECREASE        reduce using rule 96 (statement -> expression_statement .)
    LPAREN          reduce using rule 96 (statement -> expression_statement .)
    ADDRESS         reduce using rule 96 (statement -> expression_statement .)
    TIMES           reduce using rule 96 (statement -> expression_statement .)
    PLUS            reduce using rule 96 (statement -> expression_statement .)
    MINUS           reduce using rule 96 (statement -> expression_statement .)
    NOT             reduce using rule 96 (statement -> expression_statement .)
    STRING          reduce using rule 96 (statement -> expression_statement .)
    ID              reduce using rule 96 (statement -> expression_statement .)
    INT_CONST       reduce using rule 96 (statement -> expression_statement .)
    CHAR_CONST      reduce using rule 96 (statement -> expression_statement .)
    FLOAT_CONST     reduce using rule 96 (statement -> expression_statement .)
    SEMI            reduce using rule 96 (statement -> expression_statement .)
    $end            reduce using rule 96 (statement -> expression_statement .)
    ELSE            reduce using rule 96 (statement -> expression_statement .)


state 71

    (97) statement -> compound_statement .

    IF              reduce using rule 97 (statement -> compound_statement .)
    WHILE           reduce using rule 97 (statement -> compound_statement .)
    FOR             reduce using rule 97 (statement -> compound_statement .)
    BREAK           reduce using rule 97 (statement -> compound_statement .)
    RETURN          reduce using rule 97 (statement -> compound_statement .)
    ASSERT          reduce using rule 97 (statement -> compound_statement .)
    PRINT           reduce using rule 97 (statement -> compound_statement .)
    READ            reduce using rule 97 (statement -> compound_statement .)
    VOID            reduce using rule 97 (statement -> compound_statement .)
    CHAR            reduce using rule 97 (statement -> compound_statement .)
    INT             reduce using rule 97 (statement -> compound_statement .)
    FLOAT           reduce using rule 97 (statement -> compound_statement .)
    INCREASE        reduce using rule 97 (statement -> compound_statement .)
    DECREASE        reduce using rule 97 (statement -> compound_statement .)
    LPAREN          reduce using rule 97 (statement -> compound_statement .)
    ADDRESS         reduce using rule 97 (statement -> compound_statement .)
    TIMES           reduce using rule 97 (statement -> compound_statement .)
    PLUS            reduce using rule 97 (statement -> compound_statement .)
    MINUS           reduce using rule 97 (statement -> compound_statement .)
    NOT             reduce using rule 97 (statement -> compound_statement .)
    STRING          reduce using rule 97 (statement -> compound_statement .)
    ID              reduce using rule 97 (statement -> compound_statement .)
    INT_CONST       reduce using rule 97 (statement -> compound_statement .)
    CHAR_CONST      reduce using rule 97 (statement -> compound_statement .)
    FLOAT_CONST     reduce using rule 97 (statement -> compound_statement .)
    SEMI            reduce using rule 97 (statement -> compound_statement .)
    $end            reduce using rule 97 (statement -> compound_statement .)
    ELSE            reduce using rule 97 (statement -> compound_statement .)


state 72

    (98) statement -> selection_statement .

    IF              reduce using rule 98 (statement -> selection_statement .)
    WHILE           reduce using rule 98 (statement -> selection_statement .)
    FOR             reduce using rule 98 (statement -> selection_statement .)
    BREAK           reduce using rule 98 (statement -> selection_statement .)
    RETURN          reduce using rule 98 (statement -> selection_statement .)
    ASSERT          reduce using rule 98 (statement -> selection_statement .)
    PRINT           reduce using rule 98 (statement -> selection_statement .)
    READ            reduce using rule 98 (statement -> selection_statement .)
    VOID            reduce using rule 98 (statement -> selection_statement .)
    CHAR            reduce using rule 98 (statement -> selection_statement .)
    INT             reduce using rule 98 (statement -> selection_statement .)
    FLOAT           reduce using rule 98 (statement -> selection_statement .)
    INCREASE        reduce using rule 98 (statement -> selection_statement .)
    DECREASE        reduce using rule 98 (statement -> selection_statement .)
    LPAREN          reduce using rule 98 (statement -> selection_statement .)
    ADDRESS         reduce using rule 98 (statement -> selection_statement .)
    TIMES           reduce using rule 98 (statement -> selection_statement .)
    PLUS            reduce using rule 98 (statement -> selection_statement .)
    MINUS           reduce using rule 98 (statement -> selection_statement .)
    NOT             reduce using rule 98 (statement -> selection_statement .)
    STRING          reduce using rule 98 (statement -> selection_statement .)
    ID              reduce using rule 98 (statement -> selection_statement .)
    INT_CONST       reduce using rule 98 (statement -> selection_statement .)
    CHAR_CONST      reduce using rule 98 (statement -> selection_statement .)
    FLOAT_CONST     reduce using rule 98 (statement -> selection_statement .)
    SEMI            reduce using rule 98 (statement -> selection_statement .)
    $end            reduce using rule 98 (statement -> selection_statement .)
    ELSE            reduce using rule 98 (statement -> selection_statement .)


state 73

    (99) statement -> iteration_statement .

    IF              reduce using rule 99 (statement -> iteration_statement .)
    WHILE           reduce using rule 99 (statement -> iteration_statement .)
    FOR             reduce using rule 99 (statement -> iteration_statement .)
    BREAK           reduce using rule 99 (statement -> iteration_statement .)
    RETURN          reduce using rule 99 (statement -> iteration_statement .)
    ASSERT          reduce using rule 99 (statement -> iteration_statement .)
    PRINT           reduce using rule 99 (statement -> iteration_statement .)
    READ            reduce using rule 99 (statement -> iteration_statement .)
    VOID            reduce using rule 99 (statement -> iteration_statement .)
    CHAR            reduce using rule 99 (statement -> iteration_statement .)
    INT             reduce using rule 99 (statement -> iteration_statement .)
    FLOAT           reduce using rule 99 (statement -> iteration_statement .)
    INCREASE        reduce using rule 99 (statement -> iteration_statement .)
    DECREASE        reduce using rule 99 (statement -> iteration_statement .)
    LPAREN          reduce using rule 99 (statement -> iteration_statement .)
    ADDRESS         reduce using rule 99 (statement -> iteration_statement .)
    TIMES           reduce using rule 99 (statement -> iteration_statement .)
    PLUS            reduce using rule 99 (statement -> iteration_statement .)
    MINUS           reduce using rule 99 (statement -> iteration_statement .)
    NOT             reduce using rule 99 (statement -> iteration_statement .)
    STRING          reduce using rule 99 (statement -> iteration_statement .)
    ID              reduce using rule 99 (statement -> iteration_statement .)
    INT_CONST       reduce using rule 99 (statement -> iteration_statement .)
    CHAR_CONST      reduce using rule 99 (statement -> iteration_statement .)
    FLOAT_CONST     reduce using rule 99 (statement -> iteration_statement .)
    SEMI            reduce using rule 99 (statement -> iteration_statement .)
    $end            reduce using rule 99 (statement -> iteration_statement .)
    ELSE            reduce using rule 99 (statement -> iteration_statement .)


state 74

    (100) statement -> jump_statement .

    IF              reduce using rule 100 (statement -> jump_statement .)
    WHILE           reduce using rule 100 (statement -> jump_statement .)
    FOR             reduce using rule 100 (statement -> jump_statement .)
    BREAK           reduce using rule 100 (statement -> jump_statement .)
    RETURN          reduce using rule 100 (statement -> jump_statement .)
    ASSERT          reduce using rule 100 (statement -> jump_statement .)
    PRINT           reduce using rule 100 (statement -> jump_statement .)
    READ            reduce using rule 100 (statement -> jump_statement .)
    VOID            reduce using rule 100 (statement -> jump_statement .)
    CHAR            reduce using rule 100 (statement -> jump_statement .)
    INT             reduce using rule 100 (statement -> jump_statement .)
    FLOAT           reduce using rule 100 (statement -> jump_statement .)
    INCREASE        reduce using rule 100 (statement -> jump_statement .)
    DECREASE        reduce using rule 100 (statement -> jump_statement .)
    LPAREN          reduce using rule 100 (statement -> jump_statement .)
    ADDRESS         reduce using rule 100 (statement -> jump_statement .)
    TIMES           reduce using rule 100 (statement -> jump_statement .)
    PLUS            reduce using rule 100 (statement -> jump_statement .)
    MINUS           reduce using rule 100 (statement -> jump_statement .)
    NOT             reduce using rule 100 (statement -> jump_statement .)
    STRING          reduce using rule 100 (statement -> jump_statement .)
    ID              reduce using rule 100 (statement -> jump_statement .)
    INT_CONST       reduce using rule 100 (statement -> jump_statement .)
    CHAR_CONST      reduce using rule 100 (statement -> jump_statement .)
    FLOAT_CONST     reduce using rule 100 (statement -> jump_statement .)
    SEMI            reduce using rule 100 (statement -> jump_statement .)
    $end            reduce using rule 100 (statement -> jump_statement .)
    ELSE            reduce using rule 100 (statement -> jump_statement .)


state 75

    (101) statement -> assert_statement .

    IF              reduce using rule 101 (statement -> assert_statement .)
    WHILE           reduce using rule 101 (statement -> assert_statement .)
    FOR             reduce using rule 101 (statement -> assert_statement .)
    BREAK           reduce using rule 101 (statement -> assert_statement .)
    RETURN          reduce using rule 101 (statement -> assert_statement .)
    ASSERT          reduce using rule 101 (statement -> assert_statement .)
    PRINT           reduce using rule 101 (statement -> assert_statement .)
    READ            reduce using rule 101 (statement -> assert_statement .)
    VOID            reduce using rule 101 (statement -> assert_statement .)
    CHAR            reduce using rule 101 (statement -> assert_statement .)
    INT             reduce using rule 101 (statement -> assert_statement .)
    FLOAT           reduce using rule 101 (statement -> assert_statement .)
    INCREASE        reduce using rule 101 (statement -> assert_statement .)
    DECREASE        reduce using rule 101 (statement -> assert_statement .)
    LPAREN          reduce using rule 101 (statement -> assert_statement .)
    ADDRESS         reduce using rule 101 (statement -> assert_statement .)
    TIMES           reduce using rule 101 (statement -> assert_statement .)
    PLUS            reduce using rule 101 (statement -> assert_statement .)
    MINUS           reduce using rule 101 (statement -> assert_statement .)
    NOT             reduce using rule 101 (statement -> assert_statement .)
    STRING          reduce using rule 101 (statement -> assert_statement .)
    ID              reduce using rule 101 (statement -> assert_statement .)
    INT_CONST       reduce using rule 101 (statement -> assert_statement .)
    CHAR_CONST      reduce using rule 101 (statement -> assert_statement .)
    FLOAT_CONST     reduce using rule 101 (statement -> assert_statement .)
    SEMI            reduce using rule 101 (statement -> assert_statement .)
    $end            reduce using rule 101 (statement -> assert_statement .)
    ELSE            reduce using rule 101 (statement -> assert_statement .)


state 76

    (102) statement -> print_statement .

    IF              reduce using rule 102 (statement -> print_statement .)
    WHILE           reduce using rule 102 (statement -> print_statement .)
    FOR             reduce using rule 102 (statement -> print_statement .)
    BREAK           reduce using rule 102 (statement -> print_statement .)
    RETURN          reduce using rule 102 (statement -> print_statement .)
    ASSERT          reduce using rule 102 (statement -> print_statement .)
    PRINT           reduce using rule 102 (statement -> print_statement .)
    READ            reduce using rule 102 (statement -> print_statement .)
    VOID            reduce using rule 102 (statement -> print_statement .)
    CHAR            reduce using rule 102 (statement -> print_statement .)
    INT             reduce using rule 102 (statement -> print_statement .)
    FLOAT           reduce using rule 102 (statement -> print_statement .)
    INCREASE        reduce using rule 102 (statement -> print_statement .)
    DECREASE        reduce using rule 102 (statement -> print_statement .)
    LPAREN          reduce using rule 102 (statement -> print_statement .)
    ADDRESS         reduce using rule 102 (statement -> print_statement .)
    TIMES           reduce using rule 102 (statement -> print_statement .)
    PLUS            reduce using rule 102 (statement -> print_statement .)
    MINUS           reduce using rule 102 (statement -> print_statement .)
    NOT             reduce using rule 102 (statement -> print_statement .)
    STRING          reduce using rule 102 (statement -> print_statement .)
    ID              reduce using rule 102 (statement -> print_statement .)
    INT_CONST       reduce using rule 102 (statement -> print_statement .)
    CHAR_CONST      reduce using rule 102 (statement -> print_statement .)
    FLOAT_CONST     reduce using rule 102 (statement -> print_statement .)
    SEMI            reduce using rule 102 (statement -> print_statement .)
    $end            reduce using rule 102 (statement -> print_statement .)
    ELSE            reduce using rule 102 (statement -> print_statement .)


state 77

    (103) statement -> read_statement .

    IF              reduce using rule 103 (statement -> read_statement .)
    WHILE           reduce using rule 103 (statement -> read_statement .)
    FOR             reduce using rule 103 (statement -> read_statement .)
    BREAK           reduce using rule 103 (statement -> read_statement .)
    RETURN          reduce using rule 103 (statement -> read_statement .)
    ASSERT          reduce using rule 103 (statement -> read_statement .)
    PRINT           reduce using rule 103 (statement -> read_statement .)
    READ            reduce using rule 103 (statement -> read_statement .)
    VOID            reduce using rule 103 (statement -> read_statement .)
    CHAR            reduce using rule 103 (statement -> read_statement .)
    INT             reduce using rule 103 (statement -> read_statement .)
    FLOAT           reduce using rule 103 (statement -> read_statement .)
    INCREASE        reduce using rule 103 (statement -> read_statement .)
    DECREASE        reduce using rule 103 (statement -> read_statement .)
    LPAREN          reduce using rule 103 (statement -> read_statement .)
    ADDRESS         reduce using rule 103 (statement -> read_statement .)
    TIMES           reduce using rule 103 (statement -> read_statement .)
    PLUS            reduce using rule 103 (statement -> read_statement .)
    MINUS           reduce using rule 103 (statement -> read_statement .)
    NOT             reduce using rule 103 (statement -> read_statement .)
    STRING          reduce using rule 103 (statement -> read_statement .)
    ID              reduce using rule 103 (statement -> read_statement .)
    INT_CONST       reduce using rule 103 (statement -> read_statement .)
    CHAR_CONST      reduce using rule 103 (statement -> read_statement .)
    FLOAT_CONST     reduce using rule 103 (statement -> read_statement .)
    SEMI            reduce using rule 103 (statement -> read_statement .)
    $end            reduce using rule 103 (statement -> read_statement .)
    ELSE            reduce using rule 103 (statement -> read_statement .)


state 78

    (104) expression_statement -> expression_opt . SEMI

    SEMI            shift and go to state 131


state 79

    (107) selection_statement -> IF . LPAREN expression RPAREN statement
    (108) selection_statement -> IF . LPAREN expression RPAREN statement ELSE statement

    LPAREN          shift and go to state 132


state 80

    (105) expression_opt -> expression .
    (62) expression -> expression . COMMA assignment_expression
    (57) primary_expression -> expression .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for SEMI resolved using rule 57 (primary_expression -> expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 57 (primary_expression -> expression .)
    COMMA           shift and go to state 125
    SEMI            reduce using rule 57 (primary_expression -> expression .)
    LBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LPAREN          reduce using rule 57 (primary_expression -> expression .)
    INCREASE        reduce using rule 57 (primary_expression -> expression .)
    DECREASE        reduce using rule 57 (primary_expression -> expression .)
    EQUALS          reduce using rule 57 (primary_expression -> expression .)
    EQTIMES         reduce using rule 57 (primary_expression -> expression .)
    EQDIV           reduce using rule 57 (primary_expression -> expression .)
    EQMOD           reduce using rule 57 (primary_expression -> expression .)
    EQPLUS          reduce using rule 57 (primary_expression -> expression .)
    EQMINUS         reduce using rule 57 (primary_expression -> expression .)
    TIMES           reduce using rule 57 (primary_expression -> expression .)
    DIVIDE          reduce using rule 57 (primary_expression -> expression .)
    MOD             reduce using rule 57 (primary_expression -> expression .)
    PLUS            reduce using rule 57 (primary_expression -> expression .)
    MINUS           reduce using rule 57 (primary_expression -> expression .)
    LT              reduce using rule 57 (primary_expression -> expression .)
    LE              reduce using rule 57 (primary_expression -> expression .)
    GT              reduce using rule 57 (primary_expression -> expression .)
    GE              reduce using rule 57 (primary_expression -> expression .)
    EQ              reduce using rule 57 (primary_expression -> expression .)
    NQ              reduce using rule 57 (primary_expression -> expression .)
    AND             reduce using rule 57 (primary_expression -> expression .)
    OR              reduce using rule 57 (primary_expression -> expression .)
    RPAREN          reduce using rule 57 (primary_expression -> expression .)

  ! SEMI            [ reduce using rule 105 (expression_opt -> expression .) ]
  ! RPAREN          [ reduce using rule 105 (expression_opt -> expression .) ]
  ! COMMA           [ reduce using rule 57 (primary_expression -> expression .) ]


state 81

    (109) iteration_statement -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 133


state 82

    (110) iteration_statement -> FOR . LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> FOR . LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement

    LPAREN          shift and go to state 134


state 83

    (112) jump_statement -> BREAK .

    IF              reduce using rule 112 (jump_statement -> BREAK .)
    WHILE           reduce using rule 112 (jump_statement -> BREAK .)
    FOR             reduce using rule 112 (jump_statement -> BREAK .)
    BREAK           reduce using rule 112 (jump_statement -> BREAK .)
    RETURN          reduce using rule 112 (jump_statement -> BREAK .)
    ASSERT          reduce using rule 112 (jump_statement -> BREAK .)
    PRINT           reduce using rule 112 (jump_statement -> BREAK .)
    READ            reduce using rule 112 (jump_statement -> BREAK .)
    VOID            reduce using rule 112 (jump_statement -> BREAK .)
    CHAR            reduce using rule 112 (jump_statement -> BREAK .)
    INT             reduce using rule 112 (jump_statement -> BREAK .)
    FLOAT           reduce using rule 112 (jump_statement -> BREAK .)
    INCREASE        reduce using rule 112 (jump_statement -> BREAK .)
    DECREASE        reduce using rule 112 (jump_statement -> BREAK .)
    LPAREN          reduce using rule 112 (jump_statement -> BREAK .)
    ADDRESS         reduce using rule 112 (jump_statement -> BREAK .)
    TIMES           reduce using rule 112 (jump_statement -> BREAK .)
    PLUS            reduce using rule 112 (jump_statement -> BREAK .)
    MINUS           reduce using rule 112 (jump_statement -> BREAK .)
    NOT             reduce using rule 112 (jump_statement -> BREAK .)
    STRING          reduce using rule 112 (jump_statement -> BREAK .)
    ID              reduce using rule 112 (jump_statement -> BREAK .)
    INT_CONST       reduce using rule 112 (jump_statement -> BREAK .)
    CHAR_CONST      reduce using rule 112 (jump_statement -> BREAK .)
    FLOAT_CONST     reduce using rule 112 (jump_statement -> BREAK .)
    SEMI            reduce using rule 112 (jump_statement -> BREAK .)
    $end            reduce using rule 112 (jump_statement -> BREAK .)
    ELSE            reduce using rule 112 (jump_statement -> BREAK .)


state 84

    (113) jump_statement -> RETURN . expression_opt SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    SEMI            reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 135
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 85

    (114) assert_statement -> ASSERT . expression SEMI
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 136
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 86

    (115) print_statement -> PRINT . LPAREN expression_opt RPAREN SEMI

    LPAREN          shift and go to state 137


state 87

    (116) read_statement -> READ . LPAREN argument_expression RPAREN SEMI

    LPAREN          shift and go to state 138


state 88

    (106) expression_opt -> empty .

    SEMI            reduce using rule 106 (expression_opt -> empty .)
    RPAREN          reduce using rule 106 (expression_opt -> empty .)


state 89

    (65) assignment_expression -> binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    COMMA           reduce using rule 65 (assignment_expression -> binary_expression .)
    SEMI            reduce using rule 65 (assignment_expression -> binary_expression .)
    LBRACKET        reduce using rule 65 (assignment_expression -> binary_expression .)
    LPAREN          reduce using rule 65 (assignment_expression -> binary_expression .)
    INCREASE        reduce using rule 65 (assignment_expression -> binary_expression .)
    DECREASE        reduce using rule 65 (assignment_expression -> binary_expression .)
    EQUALS          reduce using rule 65 (assignment_expression -> binary_expression .)
    EQTIMES         reduce using rule 65 (assignment_expression -> binary_expression .)
    EQDIV           reduce using rule 65 (assignment_expression -> binary_expression .)
    EQMOD           reduce using rule 65 (assignment_expression -> binary_expression .)
    EQPLUS          reduce using rule 65 (assignment_expression -> binary_expression .)
    EQMINUS         reduce using rule 65 (assignment_expression -> binary_expression .)
    RBRACKET        reduce using rule 65 (assignment_expression -> binary_expression .)
    RPAREN          reduce using rule 65 (assignment_expression -> binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 90

    (66) assignment_expression -> unary_expression . assignment_operator assignment_expression
    (41) cast_expression -> unary_expression .
    (67) assignment_operator -> . EQUALS
    (68) assignment_operator -> . EQTIMES
    (69) assignment_operator -> . EQDIV
    (70) assignment_operator -> . EQMOD
    (71) assignment_operator -> . EQPLUS
    (72) assignment_operator -> . EQMINUS

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for EQTIMES resolved as shift
  ! shift/reduce conflict for EQDIV resolved as shift
  ! shift/reduce conflict for EQMOD resolved as shift
  ! shift/reduce conflict for EQPLUS resolved as shift
  ! shift/reduce conflict for EQMINUS resolved as shift
    COMMA           reduce using rule 41 (cast_expression -> unary_expression .)
    SEMI            reduce using rule 41 (cast_expression -> unary_expression .)
    LBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    LPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    INCREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    DECREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    TIMES           reduce using rule 41 (cast_expression -> unary_expression .)
    DIVIDE          reduce using rule 41 (cast_expression -> unary_expression .)
    MOD             reduce using rule 41 (cast_expression -> unary_expression .)
    PLUS            reduce using rule 41 (cast_expression -> unary_expression .)
    MINUS           reduce using rule 41 (cast_expression -> unary_expression .)
    LT              reduce using rule 41 (cast_expression -> unary_expression .)
    LE              reduce using rule 41 (cast_expression -> unary_expression .)
    GT              reduce using rule 41 (cast_expression -> unary_expression .)
    GE              reduce using rule 41 (cast_expression -> unary_expression .)
    EQ              reduce using rule 41 (cast_expression -> unary_expression .)
    NQ              reduce using rule 41 (cast_expression -> unary_expression .)
    AND             reduce using rule 41 (cast_expression -> unary_expression .)
    OR              reduce using rule 41 (cast_expression -> unary_expression .)
    RBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    RPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    EQUALS          shift and go to state 111
    EQTIMES         shift and go to state 112
    EQDIV           shift and go to state 113
    EQMOD           shift and go to state 114
    EQPLUS          shift and go to state 115
    EQMINUS         shift and go to state 116

  ! EQUALS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQTIMES         [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQDIV           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMOD           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQPLUS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMINUS         [ reduce using rule 41 (cast_expression -> unary_expression .) ]

    assignment_operator            shift and go to state 110

state 91

    (7) function_definition -> type_specifier declarator declaration_list compound_statement .

    VOID            reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)
    CHAR            reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)
    INT             reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)
    FLOAT           reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)
    TIMES           reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)
    ID              reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)
    $end            reduce using rule 7 (function_definition -> type_specifier declarator declaration_list compound_statement .)


state 92

    (87) init_declarator -> declarator EQUALS initializer .
    (91) initializer_list -> initializer .

  ! reduce/reduce conflict for COMMA resolved using rule 87 (init_declarator -> declarator EQUALS initializer .)
  ! reduce/reduce conflict for SEMI resolved using rule 87 (init_declarator -> declarator EQUALS initializer .)
    COMMA           reduce using rule 87 (init_declarator -> declarator EQUALS initializer .)
    SEMI            reduce using rule 87 (init_declarator -> declarator EQUALS initializer .)

  ! COMMA           [ reduce using rule 91 (initializer_list -> initializer .) ]
  ! SEMI            [ reduce using rule 91 (initializer_list -> initializer .) ]


state 93

    (88) initializer -> assignment_expression .
    (61) expression -> assignment_expression .

  ! reduce/reduce conflict for COMMA resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 61 (expression -> assignment_expression .)
    COMMA           reduce using rule 61 (expression -> assignment_expression .)
    SEMI            reduce using rule 61 (expression -> assignment_expression .)
    LBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    LPAREN          reduce using rule 61 (expression -> assignment_expression .)
    INCREASE        reduce using rule 61 (expression -> assignment_expression .)
    DECREASE        reduce using rule 61 (expression -> assignment_expression .)
    EQUALS          reduce using rule 61 (expression -> assignment_expression .)
    EQTIMES         reduce using rule 61 (expression -> assignment_expression .)
    EQDIV           reduce using rule 61 (expression -> assignment_expression .)
    EQMOD           reduce using rule 61 (expression -> assignment_expression .)
    EQPLUS          reduce using rule 61 (expression -> assignment_expression .)
    EQMINUS         reduce using rule 61 (expression -> assignment_expression .)
    TIMES           reduce using rule 61 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 61 (expression -> assignment_expression .)
    MOD             reduce using rule 61 (expression -> assignment_expression .)
    PLUS            reduce using rule 61 (expression -> assignment_expression .)
    MINUS           reduce using rule 61 (expression -> assignment_expression .)
    LT              reduce using rule 61 (expression -> assignment_expression .)
    LE              reduce using rule 61 (expression -> assignment_expression .)
    GT              reduce using rule 61 (expression -> assignment_expression .)
    GE              reduce using rule 61 (expression -> assignment_expression .)
    EQ              reduce using rule 61 (expression -> assignment_expression .)
    NQ              reduce using rule 61 (expression -> assignment_expression .)
    AND             reduce using rule 61 (expression -> assignment_expression .)
    OR              reduce using rule 61 (expression -> assignment_expression .)

  ! COMMA           [ reduce using rule 88 (initializer -> assignment_expression .) ]
  ! SEMI            [ reduce using rule 88 (initializer -> assignment_expression .) ]


state 94

    (89) initializer -> initializer_list .
    (90) initializer -> initializer_list . COMMA
    (92) initializer_list -> initializer_list . COMMA initializer

  ! shift/reduce conflict for COMMA resolved as shift
    SEMI            reduce using rule 89 (initializer -> initializer_list .)
    COMMA           shift and go to state 139

  ! COMMA           [ reduce using rule 89 (initializer -> initializer_list .) ]


state 95

    (85) init_declarator_list -> init_declarator_list COMMA init_declarator .

    COMMA           reduce using rule 85 (init_declarator_list -> init_declarator_list COMMA init_declarator .)
    SEMI            reduce using rule 85 (init_declarator_list -> init_declarator_list COMMA init_declarator .)


state 96

    (21) direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .

    VOID            reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    CHAR            reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    INT             reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    FLOAT           reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    LBRACKET        reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    LPAREN          reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    EQUALS          reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    COMMA           reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    SEMI            reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)
    RPAREN          reduce using rule 21 (direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET .)


state 97

    (28) binary_expression -> binary_expression TIMES . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 140
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 98

    (29) binary_expression -> binary_expression DIVIDE . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 141
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 99

    (30) binary_expression -> binary_expression MOD . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 142
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 100

    (31) binary_expression -> binary_expression PLUS . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 143
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 101

    (32) binary_expression -> binary_expression MINUS . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 144
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 102

    (33) binary_expression -> binary_expression LT . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 145
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 103

    (34) binary_expression -> binary_expression LE . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 146
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 104

    (35) binary_expression -> binary_expression GT . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 147
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 105

    (36) binary_expression -> binary_expression GE . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 148
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 106

    (37) binary_expression -> binary_expression EQ . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 149
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 107

    (38) binary_expression -> binary_expression NQ . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 150
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 108

    (39) binary_expression -> binary_expression AND . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 151
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 109

    (40) binary_expression -> binary_expression OR . binary_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    binary_expression              shift and go to state 152
    cast_expression                shift and go to state 43
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63

state 110

    (66) assignment_expression -> unary_expression assignment_operator . assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    unary_expression               shift and go to state 90
    assignment_expression          shift and go to state 153
    binary_expression              shift and go to state 89
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 111

    (67) assignment_operator -> EQUALS .

    INCREASE        reduce using rule 67 (assignment_operator -> EQUALS .)
    DECREASE        reduce using rule 67 (assignment_operator -> EQUALS .)
    LPAREN          reduce using rule 67 (assignment_operator -> EQUALS .)
    ADDRESS         reduce using rule 67 (assignment_operator -> EQUALS .)
    TIMES           reduce using rule 67 (assignment_operator -> EQUALS .)
    PLUS            reduce using rule 67 (assignment_operator -> EQUALS .)
    MINUS           reduce using rule 67 (assignment_operator -> EQUALS .)
    NOT             reduce using rule 67 (assignment_operator -> EQUALS .)
    STRING          reduce using rule 67 (assignment_operator -> EQUALS .)
    ID              reduce using rule 67 (assignment_operator -> EQUALS .)
    INT_CONST       reduce using rule 67 (assignment_operator -> EQUALS .)
    CHAR_CONST      reduce using rule 67 (assignment_operator -> EQUALS .)
    FLOAT_CONST     reduce using rule 67 (assignment_operator -> EQUALS .)


state 112

    (68) assignment_operator -> EQTIMES .

    INCREASE        reduce using rule 68 (assignment_operator -> EQTIMES .)
    DECREASE        reduce using rule 68 (assignment_operator -> EQTIMES .)
    LPAREN          reduce using rule 68 (assignment_operator -> EQTIMES .)
    ADDRESS         reduce using rule 68 (assignment_operator -> EQTIMES .)
    TIMES           reduce using rule 68 (assignment_operator -> EQTIMES .)
    PLUS            reduce using rule 68 (assignment_operator -> EQTIMES .)
    MINUS           reduce using rule 68 (assignment_operator -> EQTIMES .)
    NOT             reduce using rule 68 (assignment_operator -> EQTIMES .)
    STRING          reduce using rule 68 (assignment_operator -> EQTIMES .)
    ID              reduce using rule 68 (assignment_operator -> EQTIMES .)
    INT_CONST       reduce using rule 68 (assignment_operator -> EQTIMES .)
    CHAR_CONST      reduce using rule 68 (assignment_operator -> EQTIMES .)
    FLOAT_CONST     reduce using rule 68 (assignment_operator -> EQTIMES .)


state 113

    (69) assignment_operator -> EQDIV .

    INCREASE        reduce using rule 69 (assignment_operator -> EQDIV .)
    DECREASE        reduce using rule 69 (assignment_operator -> EQDIV .)
    LPAREN          reduce using rule 69 (assignment_operator -> EQDIV .)
    ADDRESS         reduce using rule 69 (assignment_operator -> EQDIV .)
    TIMES           reduce using rule 69 (assignment_operator -> EQDIV .)
    PLUS            reduce using rule 69 (assignment_operator -> EQDIV .)
    MINUS           reduce using rule 69 (assignment_operator -> EQDIV .)
    NOT             reduce using rule 69 (assignment_operator -> EQDIV .)
    STRING          reduce using rule 69 (assignment_operator -> EQDIV .)
    ID              reduce using rule 69 (assignment_operator -> EQDIV .)
    INT_CONST       reduce using rule 69 (assignment_operator -> EQDIV .)
    CHAR_CONST      reduce using rule 69 (assignment_operator -> EQDIV .)
    FLOAT_CONST     reduce using rule 69 (assignment_operator -> EQDIV .)


state 114

    (70) assignment_operator -> EQMOD .

    INCREASE        reduce using rule 70 (assignment_operator -> EQMOD .)
    DECREASE        reduce using rule 70 (assignment_operator -> EQMOD .)
    LPAREN          reduce using rule 70 (assignment_operator -> EQMOD .)
    ADDRESS         reduce using rule 70 (assignment_operator -> EQMOD .)
    TIMES           reduce using rule 70 (assignment_operator -> EQMOD .)
    PLUS            reduce using rule 70 (assignment_operator -> EQMOD .)
    MINUS           reduce using rule 70 (assignment_operator -> EQMOD .)
    NOT             reduce using rule 70 (assignment_operator -> EQMOD .)
    STRING          reduce using rule 70 (assignment_operator -> EQMOD .)
    ID              reduce using rule 70 (assignment_operator -> EQMOD .)
    INT_CONST       reduce using rule 70 (assignment_operator -> EQMOD .)
    CHAR_CONST      reduce using rule 70 (assignment_operator -> EQMOD .)
    FLOAT_CONST     reduce using rule 70 (assignment_operator -> EQMOD .)


state 115

    (71) assignment_operator -> EQPLUS .

    INCREASE        reduce using rule 71 (assignment_operator -> EQPLUS .)
    DECREASE        reduce using rule 71 (assignment_operator -> EQPLUS .)
    LPAREN          reduce using rule 71 (assignment_operator -> EQPLUS .)
    ADDRESS         reduce using rule 71 (assignment_operator -> EQPLUS .)
    TIMES           reduce using rule 71 (assignment_operator -> EQPLUS .)
    PLUS            reduce using rule 71 (assignment_operator -> EQPLUS .)
    MINUS           reduce using rule 71 (assignment_operator -> EQPLUS .)
    NOT             reduce using rule 71 (assignment_operator -> EQPLUS .)
    STRING          reduce using rule 71 (assignment_operator -> EQPLUS .)
    ID              reduce using rule 71 (assignment_operator -> EQPLUS .)
    INT_CONST       reduce using rule 71 (assignment_operator -> EQPLUS .)
    CHAR_CONST      reduce using rule 71 (assignment_operator -> EQPLUS .)
    FLOAT_CONST     reduce using rule 71 (assignment_operator -> EQPLUS .)


state 116

    (72) assignment_operator -> EQMINUS .

    INCREASE        reduce using rule 72 (assignment_operator -> EQMINUS .)
    DECREASE        reduce using rule 72 (assignment_operator -> EQMINUS .)
    LPAREN          reduce using rule 72 (assignment_operator -> EQMINUS .)
    ADDRESS         reduce using rule 72 (assignment_operator -> EQMINUS .)
    TIMES           reduce using rule 72 (assignment_operator -> EQMINUS .)
    PLUS            reduce using rule 72 (assignment_operator -> EQMINUS .)
    MINUS           reduce using rule 72 (assignment_operator -> EQMINUS .)
    NOT             reduce using rule 72 (assignment_operator -> EQMINUS .)
    STRING          reduce using rule 72 (assignment_operator -> EQMINUS .)
    ID              reduce using rule 72 (assignment_operator -> EQMINUS .)
    INT_CONST       reduce using rule 72 (assignment_operator -> EQMINUS .)
    CHAR_CONST      reduce using rule 72 (assignment_operator -> EQMINUS .)
    FLOAT_CONST     reduce using rule 72 (assignment_operator -> EQMINUS .)


state 117

    (42) cast_expression -> LPAREN type_specifier . RPAREN cast_expression

    RPAREN          shift and go to state 154


state 118

    (48) postfix_expression -> postfix_expression LBRACKET . expression RBRACKET
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    postfix_expression             shift and go to state 49
    expression                     shift and go to state 155
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 119

    (49) postfix_expression -> postfix_expression LPAREN . argument_expression_opt RPAREN
    (52) argument_expression_opt -> . argument_expression
    (53) argument_expression_opt -> . empty
    (63) argument_expression -> . assignment_expression
    (64) argument_expression -> . argument_expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    RPAREN          reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    postfix_expression             shift and go to state 49
    argument_expression_opt        shift and go to state 156
    argument_expression            shift and go to state 157
    empty                          shift and go to state 158
    assignment_expression          shift and go to state 159
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 120

    (50) postfix_expression -> postfix_expression INCREASE .

    TIMES           reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    DIVIDE          reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    MOD             reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    PLUS            reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    MINUS           reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    LT              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    LE              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    GT              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    GE              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQ              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    NQ              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    AND             reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    OR              reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    RBRACKET        reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    COMMA           reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    LBRACKET        reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    LPAREN          reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    INCREASE        reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    DECREASE        reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQUALS          reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQTIMES         reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQDIV           reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQMOD           reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQPLUS          reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    EQMINUS         reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    SEMI            reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)
    RPAREN          reduce using rule 50 (postfix_expression -> postfix_expression INCREASE .)


state 121

    (51) postfix_expression -> postfix_expression DECREASE .

    TIMES           reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    DIVIDE          reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    MOD             reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    PLUS            reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    MINUS           reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    LT              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    LE              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    GT              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    GE              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQ              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    NQ              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    AND             reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    OR              reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    RBRACKET        reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    COMMA           reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    LBRACKET        reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    LPAREN          reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    INCREASE        reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    DECREASE        reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQUALS          reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQTIMES         reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQDIV           reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQMOD           reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQPLUS          reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    EQMINUS         reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    SEMI            reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)
    RPAREN          reduce using rule 51 (postfix_expression -> postfix_expression DECREASE .)


state 122

    (44) unary_expression -> INCREASE unary_expression .
    (66) assignment_expression -> unary_expression . assignment_operator assignment_expression
    (41) cast_expression -> unary_expression .
    (67) assignment_operator -> . EQUALS
    (68) assignment_operator -> . EQTIMES
    (69) assignment_operator -> . EQDIV
    (70) assignment_operator -> . EQMOD
    (71) assignment_operator -> . EQPLUS
    (72) assignment_operator -> . EQMINUS

  ! reduce/reduce conflict for EQUALS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LT resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for GT resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 41 (cast_expression -> unary_expression .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for EQTIMES resolved as shift
  ! shift/reduce conflict for EQDIV resolved as shift
  ! shift/reduce conflict for EQMOD resolved as shift
  ! shift/reduce conflict for EQPLUS resolved as shift
  ! shift/reduce conflict for EQMINUS resolved as shift
    TIMES           reduce using rule 41 (cast_expression -> unary_expression .)
    DIVIDE          reduce using rule 41 (cast_expression -> unary_expression .)
    MOD             reduce using rule 41 (cast_expression -> unary_expression .)
    PLUS            reduce using rule 41 (cast_expression -> unary_expression .)
    MINUS           reduce using rule 41 (cast_expression -> unary_expression .)
    LT              reduce using rule 41 (cast_expression -> unary_expression .)
    LE              reduce using rule 41 (cast_expression -> unary_expression .)
    GT              reduce using rule 41 (cast_expression -> unary_expression .)
    GE              reduce using rule 41 (cast_expression -> unary_expression .)
    EQ              reduce using rule 41 (cast_expression -> unary_expression .)
    NQ              reduce using rule 41 (cast_expression -> unary_expression .)
    AND             reduce using rule 41 (cast_expression -> unary_expression .)
    OR              reduce using rule 41 (cast_expression -> unary_expression .)
    RBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    COMMA           reduce using rule 41 (cast_expression -> unary_expression .)
    LBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    LPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    INCREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    DECREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    SEMI            reduce using rule 41 (cast_expression -> unary_expression .)
    RPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    EQUALS          shift and go to state 111
    EQTIMES         shift and go to state 112
    EQDIV           shift and go to state 113
    EQMOD           shift and go to state 114
    EQPLUS          shift and go to state 115
    EQMINUS         shift and go to state 116

  ! TIMES           [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! DIVIDE          [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! MOD             [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! PLUS            [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! MINUS           [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! LT              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! LE              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! GT              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! GE              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQ              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! NQ              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! AND             [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! OR              [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! RBRACKET        [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! COMMA           [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! LBRACKET        [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! LPAREN          [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! INCREASE        [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! DECREASE        [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQUALS          [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQTIMES         [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQDIV           [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQMOD           [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQPLUS          [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQMINUS         [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! SEMI            [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! RPAREN          [ reduce using rule 44 (unary_expression -> INCREASE unary_expression .) ]
  ! EQUALS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQTIMES         [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQDIV           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMOD           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQPLUS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMINUS         [ reduce using rule 41 (cast_expression -> unary_expression .) ]

    assignment_operator            shift and go to state 110

state 123

    (45) unary_expression -> DECREASE unary_expression .
    (66) assignment_expression -> unary_expression . assignment_operator assignment_expression
    (41) cast_expression -> unary_expression .
    (67) assignment_operator -> . EQUALS
    (68) assignment_operator -> . EQTIMES
    (69) assignment_operator -> . EQDIV
    (70) assignment_operator -> . EQMOD
    (71) assignment_operator -> . EQPLUS
    (72) assignment_operator -> . EQMINUS

  ! reduce/reduce conflict for EQUALS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LT resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for GT resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 41 (cast_expression -> unary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 41 (cast_expression -> unary_expression .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for EQTIMES resolved as shift
  ! shift/reduce conflict for EQDIV resolved as shift
  ! shift/reduce conflict for EQMOD resolved as shift
  ! shift/reduce conflict for EQPLUS resolved as shift
  ! shift/reduce conflict for EQMINUS resolved as shift
    TIMES           reduce using rule 41 (cast_expression -> unary_expression .)
    DIVIDE          reduce using rule 41 (cast_expression -> unary_expression .)
    MOD             reduce using rule 41 (cast_expression -> unary_expression .)
    PLUS            reduce using rule 41 (cast_expression -> unary_expression .)
    MINUS           reduce using rule 41 (cast_expression -> unary_expression .)
    LT              reduce using rule 41 (cast_expression -> unary_expression .)
    LE              reduce using rule 41 (cast_expression -> unary_expression .)
    GT              reduce using rule 41 (cast_expression -> unary_expression .)
    GE              reduce using rule 41 (cast_expression -> unary_expression .)
    EQ              reduce using rule 41 (cast_expression -> unary_expression .)
    NQ              reduce using rule 41 (cast_expression -> unary_expression .)
    AND             reduce using rule 41 (cast_expression -> unary_expression .)
    OR              reduce using rule 41 (cast_expression -> unary_expression .)
    RBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    COMMA           reduce using rule 41 (cast_expression -> unary_expression .)
    LBRACKET        reduce using rule 41 (cast_expression -> unary_expression .)
    LPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    INCREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    DECREASE        reduce using rule 41 (cast_expression -> unary_expression .)
    SEMI            reduce using rule 41 (cast_expression -> unary_expression .)
    RPAREN          reduce using rule 41 (cast_expression -> unary_expression .)
    EQUALS          shift and go to state 111
    EQTIMES         shift and go to state 112
    EQDIV           shift and go to state 113
    EQMOD           shift and go to state 114
    EQPLUS          shift and go to state 115
    EQMINUS         shift and go to state 116

  ! TIMES           [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! DIVIDE          [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! MOD             [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! PLUS            [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! MINUS           [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! LT              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! LE              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! GT              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! GE              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQ              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! NQ              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! AND             [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! OR              [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! RBRACKET        [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! COMMA           [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! LBRACKET        [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! LPAREN          [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! INCREASE        [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! DECREASE        [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQUALS          [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQTIMES         [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQDIV           [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQMOD           [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQPLUS          [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQMINUS         [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! SEMI            [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! RPAREN          [ reduce using rule 45 (unary_expression -> DECREASE unary_expression .) ]
  ! EQUALS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQTIMES         [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQDIV           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMOD           [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQPLUS          [ reduce using rule 41 (cast_expression -> unary_expression .) ]
  ! EQMINUS         [ reduce using rule 41 (cast_expression -> unary_expression .) ]

    assignment_operator            shift and go to state 110

state 124

    (46) unary_expression -> unary_operator cast_expression .
    (27) binary_expression -> cast_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LT resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for GT resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for GE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for AND resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for OR resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (binary_expression -> cast_expression .)
    EQUALS          reduce using rule 27 (binary_expression -> cast_expression .)
    EQTIMES         reduce using rule 27 (binary_expression -> cast_expression .)
    EQDIV           reduce using rule 27 (binary_expression -> cast_expression .)
    EQMOD           reduce using rule 27 (binary_expression -> cast_expression .)
    EQPLUS          reduce using rule 27 (binary_expression -> cast_expression .)
    EQMINUS         reduce using rule 27 (binary_expression -> cast_expression .)
    TIMES           reduce using rule 27 (binary_expression -> cast_expression .)
    DIVIDE          reduce using rule 27 (binary_expression -> cast_expression .)
    MOD             reduce using rule 27 (binary_expression -> cast_expression .)
    PLUS            reduce using rule 27 (binary_expression -> cast_expression .)
    MINUS           reduce using rule 27 (binary_expression -> cast_expression .)
    LT              reduce using rule 27 (binary_expression -> cast_expression .)
    LE              reduce using rule 27 (binary_expression -> cast_expression .)
    GT              reduce using rule 27 (binary_expression -> cast_expression .)
    GE              reduce using rule 27 (binary_expression -> cast_expression .)
    EQ              reduce using rule 27 (binary_expression -> cast_expression .)
    NQ              reduce using rule 27 (binary_expression -> cast_expression .)
    AND             reduce using rule 27 (binary_expression -> cast_expression .)
    OR              reduce using rule 27 (binary_expression -> cast_expression .)
    RBRACKET        reduce using rule 27 (binary_expression -> cast_expression .)
    COMMA           reduce using rule 27 (binary_expression -> cast_expression .)
    LBRACKET        reduce using rule 27 (binary_expression -> cast_expression .)
    LPAREN          reduce using rule 27 (binary_expression -> cast_expression .)
    INCREASE        reduce using rule 27 (binary_expression -> cast_expression .)
    DECREASE        reduce using rule 27 (binary_expression -> cast_expression .)
    SEMI            reduce using rule 27 (binary_expression -> cast_expression .)
    RPAREN          reduce using rule 27 (binary_expression -> cast_expression .)

  ! TIMES           [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! DIVIDE          [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! MOD             [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! PLUS            [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! MINUS           [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! LT              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! LE              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! GT              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! GE              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQ              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! NQ              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! AND             [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! OR              [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! RBRACKET        [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! COMMA           [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! LBRACKET        [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! LPAREN          [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! INCREASE        [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! DECREASE        [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQUALS          [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQTIMES         [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQDIV           [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQMOD           [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQPLUS          [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! EQMINUS         [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! SEMI            [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]
  ! RPAREN          [ reduce using rule 46 (unary_expression -> unary_operator cast_expression .) ]


state 125

    (62) expression -> expression COMMA . assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 54
    assignment_expression          shift and go to state 160
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 126

    (22) direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .

    VOID            reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    CHAR            reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    INT             reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    FLOAT           reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    LBRACKET        reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    LPAREN          reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    EQUALS          reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    COMMA           reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    SEMI            reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)
    RPAREN          reduce using rule 22 (direct_declarator -> direct_declarator LPAREN parameter_list RPAREN .)


state 127

    (79) parameter_list -> parameter_list COMMA . parameter_declaration
    (80) parameter_declaration -> . type_specifier declarator
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT

    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13

    parameter_declaration          shift and go to state 161
    type_specifier                 shift and go to state 67

state 128

    (23) direct_declarator -> direct_declarator LPAREN identifier RPAREN .

    VOID            reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    CHAR            reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    INT             reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    FLOAT           reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    LBRACKET        reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    LPAREN          reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    EQUALS          reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    COMMA           reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    SEMI            reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)
    RPAREN          reduce using rule 23 (direct_declarator -> direct_declarator LPAREN identifier RPAREN .)


state 129

    (80) parameter_declaration -> type_specifier declarator .
    (20) direct_declarator -> declarator .

  ! reduce/reduce conflict for RPAREN resolved using rule 20 (direct_declarator -> declarator .)
  ! reduce/reduce conflict for COMMA resolved using rule 20 (direct_declarator -> declarator .)
    RPAREN          reduce using rule 20 (direct_declarator -> declarator .)
    COMMA           reduce using rule 20 (direct_declarator -> declarator .)
    LBRACKET        reduce using rule 20 (direct_declarator -> declarator .)
    LPAREN          reduce using rule 20 (direct_declarator -> declarator .)

  ! RPAREN          [ reduce using rule 80 (parameter_declaration -> type_specifier declarator .) ]
  ! COMMA           [ reduce using rule 80 (parameter_declaration -> type_specifier declarator .) ]


state 130

    (95) statement_list -> statement_list statement .

    IF              reduce using rule 95 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 95 (statement_list -> statement_list statement .)
    FOR             reduce using rule 95 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 95 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 95 (statement_list -> statement_list statement .)
    ASSERT          reduce using rule 95 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 95 (statement_list -> statement_list statement .)
    READ            reduce using rule 95 (statement_list -> statement_list statement .)
    VOID            reduce using rule 95 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 95 (statement_list -> statement_list statement .)
    INT             reduce using rule 95 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 95 (statement_list -> statement_list statement .)
    INCREASE        reduce using rule 95 (statement_list -> statement_list statement .)
    DECREASE        reduce using rule 95 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 95 (statement_list -> statement_list statement .)
    ADDRESS         reduce using rule 95 (statement_list -> statement_list statement .)
    TIMES           reduce using rule 95 (statement_list -> statement_list statement .)
    PLUS            reduce using rule 95 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 95 (statement_list -> statement_list statement .)
    NOT             reduce using rule 95 (statement_list -> statement_list statement .)
    STRING          reduce using rule 95 (statement_list -> statement_list statement .)
    ID              reduce using rule 95 (statement_list -> statement_list statement .)
    INT_CONST       reduce using rule 95 (statement_list -> statement_list statement .)
    CHAR_CONST      reduce using rule 95 (statement_list -> statement_list statement .)
    FLOAT_CONST     reduce using rule 95 (statement_list -> statement_list statement .)
    SEMI            reduce using rule 95 (statement_list -> statement_list statement .)
    $end            reduce using rule 95 (statement_list -> statement_list statement .)
    ELSE            reduce using rule 95 (statement_list -> statement_list statement .)


state 131

    (104) expression_statement -> expression_opt SEMI .

    IF              reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    WHILE           reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    FOR             reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    BREAK           reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    RETURN          reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    ASSERT          reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    PRINT           reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    READ            reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    VOID            reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    CHAR            reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    INT             reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    FLOAT           reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    INCREASE        reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    DECREASE        reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    LPAREN          reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    ADDRESS         reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    TIMES           reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    PLUS            reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    MINUS           reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    NOT             reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    STRING          reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    ID              reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    INT_CONST       reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    CHAR_CONST      reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    FLOAT_CONST     reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    SEMI            reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    $end            reduce using rule 104 (expression_statement -> expression_opt SEMI .)
    ELSE            reduce using rule 104 (expression_statement -> expression_opt SEMI .)


state 132

    (107) selection_statement -> IF LPAREN . expression RPAREN statement
    (108) selection_statement -> IF LPAREN . expression RPAREN statement ELSE statement
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 162
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 133

    (109) iteration_statement -> WHILE LPAREN . expression RPAREN statement
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 163
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 134

    (110) iteration_statement -> FOR LPAREN . expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> FOR LPAREN . declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    SEMI            reduce using rule 117 (empty -> .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 164
    declaration                    shift and go to state 165
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    type_specifier                 shift and go to state 20
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 135

    (113) jump_statement -> RETURN expression_opt . SEMI

    SEMI            shift and go to state 166


state 136

    (114) assert_statement -> ASSERT expression . SEMI
    (62) expression -> expression . COMMA assignment_expression
    (57) primary_expression -> expression .

  ! shift/reduce conflict for SEMI resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    SEMI            shift and go to state 167
    COMMA           shift and go to state 125
    EQUALS          reduce using rule 57 (primary_expression -> expression .)
    EQTIMES         reduce using rule 57 (primary_expression -> expression .)
    EQDIV           reduce using rule 57 (primary_expression -> expression .)
    EQMOD           reduce using rule 57 (primary_expression -> expression .)
    EQPLUS          reduce using rule 57 (primary_expression -> expression .)
    EQMINUS         reduce using rule 57 (primary_expression -> expression .)
    TIMES           reduce using rule 57 (primary_expression -> expression .)
    DIVIDE          reduce using rule 57 (primary_expression -> expression .)
    MOD             reduce using rule 57 (primary_expression -> expression .)
    PLUS            reduce using rule 57 (primary_expression -> expression .)
    MINUS           reduce using rule 57 (primary_expression -> expression .)
    LT              reduce using rule 57 (primary_expression -> expression .)
    LE              reduce using rule 57 (primary_expression -> expression .)
    GT              reduce using rule 57 (primary_expression -> expression .)
    GE              reduce using rule 57 (primary_expression -> expression .)
    EQ              reduce using rule 57 (primary_expression -> expression .)
    NQ              reduce using rule 57 (primary_expression -> expression .)
    AND             reduce using rule 57 (primary_expression -> expression .)
    OR              reduce using rule 57 (primary_expression -> expression .)
    LBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LPAREN          reduce using rule 57 (primary_expression -> expression .)
    INCREASE        reduce using rule 57 (primary_expression -> expression .)
    DECREASE        reduce using rule 57 (primary_expression -> expression .)

  ! SEMI            [ reduce using rule 57 (primary_expression -> expression .) ]
  ! COMMA           [ reduce using rule 57 (primary_expression -> expression .) ]


state 137

    (115) print_statement -> PRINT LPAREN . expression_opt RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    RPAREN          reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 168
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 138

    (116) read_statement -> READ LPAREN . argument_expression RPAREN SEMI
    (63) argument_expression -> . assignment_expression
    (64) argument_expression -> . argument_expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    argument_expression            shift and go to state 169
    assignment_expression          shift and go to state 159
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 139

    (90) initializer -> initializer_list COMMA .
    (92) initializer_list -> initializer_list COMMA . initializer
    (88) initializer -> . assignment_expression
    (89) initializer -> . initializer_list
    (90) initializer -> . initializer_list COMMA
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (91) initializer_list -> . initializer
    (92) initializer_list -> . initializer_list COMMA initializer
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    COMMA           reduce using rule 90 (initializer -> initializer_list COMMA .)
    SEMI            reduce using rule 90 (initializer -> initializer_list COMMA .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    initializer_list               shift and go to state 94
    initializer                    shift and go to state 170
    assignment_expression          shift and go to state 93
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 140

    (28) binary_expression -> binary_expression TIMES binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for LT resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for LE resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for GT resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    TIMES           reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    DIVIDE          reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    MOD             reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    PLUS            reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    MINUS           reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    LT              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    LE              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    GT              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    GE              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQ              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    NQ              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    AND             reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    OR              reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    RBRACKET        reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    COMMA           reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    LBRACKET        reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    LPAREN          reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    INCREASE        reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    DECREASE        reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQUALS          reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQTIMES         reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQDIV           reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQMOD           reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQPLUS          reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    EQMINUS         reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    SEMI            reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)
    RPAREN          reduce using rule 28 (binary_expression -> binary_expression TIMES binary_expression .)

  ! TIMES           [ shift and go to state 97 ]
  ! DIVIDE          [ shift and go to state 98 ]
  ! MOD             [ shift and go to state 99 ]
  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! LT              [ shift and go to state 102 ]
  ! LE              [ shift and go to state 103 ]
  ! GT              [ shift and go to state 104 ]
  ! GE              [ shift and go to state 105 ]
  ! EQ              [ shift and go to state 106 ]
  ! NQ              [ shift and go to state 107 ]
  ! AND             [ shift and go to state 108 ]
  ! OR              [ shift and go to state 109 ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 141

    (29) binary_expression -> binary_expression DIVIDE binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for LT resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for LE resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for GT resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    TIMES           reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    DIVIDE          reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    MOD             reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    PLUS            reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    MINUS           reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    LT              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    LE              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    GT              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    GE              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQ              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    NQ              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    AND             reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    OR              reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    RBRACKET        reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    COMMA           reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    LBRACKET        reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    LPAREN          reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    INCREASE        reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    DECREASE        reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQUALS          reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQTIMES         reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQDIV           reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQMOD           reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQPLUS          reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQMINUS         reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    SEMI            reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)
    RPAREN          reduce using rule 29 (binary_expression -> binary_expression DIVIDE binary_expression .)

  ! TIMES           [ shift and go to state 97 ]
  ! DIVIDE          [ shift and go to state 98 ]
  ! MOD             [ shift and go to state 99 ]
  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! LT              [ shift and go to state 102 ]
  ! LE              [ shift and go to state 103 ]
  ! GT              [ shift and go to state 104 ]
  ! GE              [ shift and go to state 105 ]
  ! EQ              [ shift and go to state 106 ]
  ! NQ              [ shift and go to state 107 ]
  ! AND             [ shift and go to state 108 ]
  ! OR              [ shift and go to state 109 ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 142

    (30) binary_expression -> binary_expression MOD binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    RBRACKET        reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    COMMA           reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    LBRACKET        reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    LPAREN          reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    INCREASE        reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    DECREASE        reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    EQUALS          reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    EQTIMES         reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    EQDIV           reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    EQMOD           reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    EQPLUS          reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    EQMINUS         reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    SEMI            reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    RPAREN          reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! DIVIDE          [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! MOD             [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! PLUS            [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! MINUS           [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! LT              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! LE              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! GT              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! GE              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! EQ              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! NQ              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! AND             [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! OR              [ reduce using rule 30 (binary_expression -> binary_expression MOD binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 143

    (31) binary_expression -> binary_expression PLUS binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for MOD resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for LT resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for LE resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for GT resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    MOD             reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    PLUS            reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    MINUS           reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    LT              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    LE              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    GT              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    GE              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQ              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    NQ              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    AND             reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    OR              reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    RBRACKET        reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    COMMA           reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    LBRACKET        reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    LPAREN          reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    INCREASE        reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    DECREASE        reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQUALS          reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQTIMES         reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQDIV           reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQMOD           reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQPLUS          reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    EQMINUS         reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    SEMI            reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    RPAREN          reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98

  ! TIMES           [ reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .) ]
  ! DIVIDE          [ reduce using rule 31 (binary_expression -> binary_expression PLUS binary_expression .) ]
  ! MOD             [ shift and go to state 99 ]
  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! LT              [ shift and go to state 102 ]
  ! LE              [ shift and go to state 103 ]
  ! GT              [ shift and go to state 104 ]
  ! GE              [ shift and go to state 105 ]
  ! EQ              [ shift and go to state 106 ]
  ! NQ              [ shift and go to state 107 ]
  ! AND             [ shift and go to state 108 ]
  ! OR              [ shift and go to state 109 ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 144

    (32) binary_expression -> binary_expression MINUS binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for MOD resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for LT resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for LE resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for GT resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    MOD             reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    PLUS            reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    MINUS           reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    LT              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    LE              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    GT              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    GE              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQ              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    NQ              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    AND             reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    OR              reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    RBRACKET        reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    COMMA           reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    LBRACKET        reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    LPAREN          reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    INCREASE        reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    DECREASE        reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQUALS          reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQTIMES         reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQDIV           reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQMOD           reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQPLUS          reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    EQMINUS         reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    SEMI            reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    RPAREN          reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98

  ! TIMES           [ reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .) ]
  ! DIVIDE          [ reduce using rule 32 (binary_expression -> binary_expression MINUS binary_expression .) ]
  ! MOD             [ shift and go to state 99 ]
  ! PLUS            [ shift and go to state 100 ]
  ! MINUS           [ shift and go to state 101 ]
  ! LT              [ shift and go to state 102 ]
  ! LE              [ shift and go to state 103 ]
  ! GT              [ shift and go to state 104 ]
  ! GE              [ shift and go to state 105 ]
  ! EQ              [ shift and go to state 106 ]
  ! NQ              [ shift and go to state 107 ]
  ! AND             [ shift and go to state 108 ]
  ! OR              [ shift and go to state 109 ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 145

    (33) binary_expression -> binary_expression LT binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for MOD resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for LE resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    MOD             reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    LE              reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    GE              reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQ              reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    NQ              reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    AND             reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    OR              reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    RBRACKET        reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    COMMA           reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    LBRACKET        reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    LPAREN          reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    INCREASE        reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    DECREASE        reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQUALS          reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQTIMES         reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQDIV           reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQMOD           reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQPLUS          reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    EQMINUS         reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    SEMI            reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    RPAREN          reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              reduce using rule 65 (assignment_expression -> binary_expression .)
    GT              reduce using rule 65 (assignment_expression -> binary_expression .)

  ! TIMES           [ reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .) ]
  ! DIVIDE          [ reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .) ]
  ! PLUS            [ reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .) ]
  ! MINUS           [ reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .) ]
  ! LT              [ reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .) ]
  ! GT              [ reduce using rule 33 (binary_expression -> binary_expression LT binary_expression .) ]
  ! MOD             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 102 ]
  ! LE              [ shift and go to state 103 ]
  ! GT              [ shift and go to state 104 ]
  ! GE              [ shift and go to state 105 ]
  ! EQ              [ shift and go to state 106 ]
  ! NQ              [ shift and go to state 107 ]
  ! AND             [ shift and go to state 108 ]
  ! OR              [ shift and go to state 109 ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 146

    (34) binary_expression -> binary_expression LE binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    RBRACKET        reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    COMMA           reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    LBRACKET        reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    LPAREN          reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    INCREASE        reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    DECREASE        reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    EQUALS          reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    EQTIMES         reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    EQDIV           reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    EQMOD           reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    EQPLUS          reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    EQMINUS         reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    SEMI            reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    RPAREN          reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! DIVIDE          [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! MOD             [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! PLUS            [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! MINUS           [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! LT              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! LE              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! GT              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! GE              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! EQ              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! NQ              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! AND             [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! OR              [ reduce using rule 34 (binary_expression -> binary_expression LE binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 147

    (35) binary_expression -> binary_expression GT binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! reduce/reduce conflict for MOD resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for LE resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for GE resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for AND resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for OR resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    MOD             reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    LE              reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    GE              reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQ              reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    NQ              reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    AND             reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    OR              reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    RBRACKET        reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    COMMA           reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    LBRACKET        reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    LPAREN          reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    INCREASE        reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    DECREASE        reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQUALS          reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQTIMES         reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQDIV           reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQMOD           reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQPLUS          reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    EQMINUS         reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    SEMI            reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    RPAREN          reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              reduce using rule 65 (assignment_expression -> binary_expression .)
    GT              reduce using rule 65 (assignment_expression -> binary_expression .)

  ! TIMES           [ reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .) ]
  ! DIVIDE          [ reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .) ]
  ! PLUS            [ reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .) ]
  ! MINUS           [ reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .) ]
  ! LT              [ reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .) ]
  ! GT              [ reduce using rule 35 (binary_expression -> binary_expression GT binary_expression .) ]
  ! MOD             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 102 ]
  ! LE              [ shift and go to state 103 ]
  ! GT              [ shift and go to state 104 ]
  ! GE              [ shift and go to state 105 ]
  ! EQ              [ shift and go to state 106 ]
  ! NQ              [ shift and go to state 107 ]
  ! AND             [ shift and go to state 108 ]
  ! OR              [ shift and go to state 109 ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 148

    (36) binary_expression -> binary_expression GE binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    RBRACKET        reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    COMMA           reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    LBRACKET        reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    LPAREN          reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    INCREASE        reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    DECREASE        reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    EQUALS          reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    EQTIMES         reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    EQDIV           reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    EQMOD           reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    EQPLUS          reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    EQMINUS         reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    SEMI            reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    RPAREN          reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! DIVIDE          [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! MOD             [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! PLUS            [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! MINUS           [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! LT              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! LE              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! GT              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! GE              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! EQ              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! NQ              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! AND             [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! OR              [ reduce using rule 36 (binary_expression -> binary_expression GE binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 149

    (37) binary_expression -> binary_expression EQ binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    RBRACKET        reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    COMMA           reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    LBRACKET        reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    LPAREN          reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    INCREASE        reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    DECREASE        reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    EQUALS          reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    EQTIMES         reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    EQDIV           reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    EQMOD           reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    EQPLUS          reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    EQMINUS         reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    SEMI            reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    RPAREN          reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! DIVIDE          [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! MOD             [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! PLUS            [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! MINUS           [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! LT              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! LE              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! GT              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! GE              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! EQ              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! NQ              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! AND             [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! OR              [ reduce using rule 37 (binary_expression -> binary_expression EQ binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 150

    (38) binary_expression -> binary_expression NQ binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    RBRACKET        reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    COMMA           reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    LBRACKET        reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    LPAREN          reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    INCREASE        reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    DECREASE        reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    EQUALS          reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    EQTIMES         reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    EQDIV           reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    EQMOD           reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    EQPLUS          reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    EQMINUS         reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    SEMI            reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    RPAREN          reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! DIVIDE          [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! MOD             [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! PLUS            [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! MINUS           [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! LT              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! LE              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! GT              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! GE              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! EQ              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! NQ              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! AND             [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! OR              [ reduce using rule 38 (binary_expression -> binary_expression NQ binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 151

    (39) binary_expression -> binary_expression AND binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    RBRACKET        reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    COMMA           reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    LBRACKET        reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    LPAREN          reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    INCREASE        reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    DECREASE        reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    EQUALS          reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    EQTIMES         reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    EQDIV           reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    EQMOD           reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    EQPLUS          reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    EQMINUS         reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    SEMI            reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    RPAREN          reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! DIVIDE          [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! MOD             [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! PLUS            [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! MINUS           [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! LT              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! LE              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! GT              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! GE              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! EQ              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! NQ              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! AND             [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! OR              [ reduce using rule 39 (binary_expression -> binary_expression AND binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 152

    (40) binary_expression -> binary_expression OR binary_expression .
    (28) binary_expression -> binary_expression . TIMES binary_expression
    (29) binary_expression -> binary_expression . DIVIDE binary_expression
    (30) binary_expression -> binary_expression . MOD binary_expression
    (31) binary_expression -> binary_expression . PLUS binary_expression
    (32) binary_expression -> binary_expression . MINUS binary_expression
    (33) binary_expression -> binary_expression . LT binary_expression
    (34) binary_expression -> binary_expression . LE binary_expression
    (35) binary_expression -> binary_expression . GT binary_expression
    (36) binary_expression -> binary_expression . GE binary_expression
    (37) binary_expression -> binary_expression . EQ binary_expression
    (38) binary_expression -> binary_expression . NQ binary_expression
    (39) binary_expression -> binary_expression . AND binary_expression
    (40) binary_expression -> binary_expression . OR binary_expression
    (65) assignment_expression -> binary_expression .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    RBRACKET        reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    COMMA           reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    LBRACKET        reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    LPAREN          reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    INCREASE        reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    DECREASE        reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    EQUALS          reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    EQTIMES         reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    EQDIV           reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    EQMOD           reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    EQPLUS          reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    EQMINUS         reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    SEMI            reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    RPAREN          reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .)
    TIMES           shift and go to state 97
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NQ              shift and go to state 107
    AND             shift and go to state 108
    OR              shift and go to state 109

  ! TIMES           [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! DIVIDE          [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! MOD             [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! PLUS            [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! MINUS           [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! LT              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! LE              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! GT              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! GE              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! EQ              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! NQ              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! AND             [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! OR              [ reduce using rule 40 (binary_expression -> binary_expression OR binary_expression .) ]
  ! EQUALS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQTIMES         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQDIV           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMOD           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQPLUS          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQMINUS         [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! TIMES           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DIVIDE          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MOD             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! PLUS            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GT              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! GE              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! EQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! NQ              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! AND             [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! OR              [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! COMMA           [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LBRACKET        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! LPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! INCREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! DECREASE        [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! SEMI            [ reduce using rule 65 (assignment_expression -> binary_expression .) ]
  ! RPAREN          [ reduce using rule 65 (assignment_expression -> binary_expression .) ]


state 153

    (66) assignment_expression -> unary_expression assignment_operator assignment_expression .
    (61) expression -> assignment_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LT resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for GT resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for GE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for AND resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for OR resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (expression -> assignment_expression .)
    EQUALS          reduce using rule 61 (expression -> assignment_expression .)
    EQTIMES         reduce using rule 61 (expression -> assignment_expression .)
    EQDIV           reduce using rule 61 (expression -> assignment_expression .)
    EQMOD           reduce using rule 61 (expression -> assignment_expression .)
    EQPLUS          reduce using rule 61 (expression -> assignment_expression .)
    EQMINUS         reduce using rule 61 (expression -> assignment_expression .)
    TIMES           reduce using rule 61 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 61 (expression -> assignment_expression .)
    MOD             reduce using rule 61 (expression -> assignment_expression .)
    PLUS            reduce using rule 61 (expression -> assignment_expression .)
    MINUS           reduce using rule 61 (expression -> assignment_expression .)
    LT              reduce using rule 61 (expression -> assignment_expression .)
    LE              reduce using rule 61 (expression -> assignment_expression .)
    GT              reduce using rule 61 (expression -> assignment_expression .)
    GE              reduce using rule 61 (expression -> assignment_expression .)
    EQ              reduce using rule 61 (expression -> assignment_expression .)
    NQ              reduce using rule 61 (expression -> assignment_expression .)
    AND             reduce using rule 61 (expression -> assignment_expression .)
    OR              reduce using rule 61 (expression -> assignment_expression .)
    RBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    COMMA           reduce using rule 61 (expression -> assignment_expression .)
    LBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    LPAREN          reduce using rule 61 (expression -> assignment_expression .)
    INCREASE        reduce using rule 61 (expression -> assignment_expression .)
    DECREASE        reduce using rule 61 (expression -> assignment_expression .)
    SEMI            reduce using rule 61 (expression -> assignment_expression .)
    RPAREN          reduce using rule 61 (expression -> assignment_expression .)

  ! TIMES           [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! DIVIDE          [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! MOD             [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! PLUS            [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! MINUS           [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! LT              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! LE              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! GT              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! GE              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQ              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! NQ              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! AND             [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! OR              [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! RBRACKET        [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! COMMA           [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! LBRACKET        [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! LPAREN          [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! INCREASE        [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! DECREASE        [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQUALS          [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQTIMES         [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQDIV           [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQMOD           [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQPLUS          [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! EQMINUS         [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! SEMI            [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]
  ! RPAREN          [ reduce using rule 66 (assignment_expression -> unary_expression assignment_operator assignment_expression .) ]


state 154

    (42) cast_expression -> LPAREN type_specifier RPAREN . cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression

    LPAREN          shift and go to state 48
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    cast_expression                shift and go to state 171
    unary_expression               shift and go to state 47
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89

state 155

    (48) postfix_expression -> postfix_expression LBRACKET expression . RBRACKET
    (62) expression -> expression . COMMA assignment_expression
    (57) primary_expression -> expression .

  ! shift/reduce conflict for RBRACKET resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RBRACKET        shift and go to state 172
    COMMA           shift and go to state 125
    LBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LPAREN          reduce using rule 57 (primary_expression -> expression .)
    INCREASE        reduce using rule 57 (primary_expression -> expression .)
    DECREASE        reduce using rule 57 (primary_expression -> expression .)
    EQUALS          reduce using rule 57 (primary_expression -> expression .)
    EQTIMES         reduce using rule 57 (primary_expression -> expression .)
    EQDIV           reduce using rule 57 (primary_expression -> expression .)
    EQMOD           reduce using rule 57 (primary_expression -> expression .)
    EQPLUS          reduce using rule 57 (primary_expression -> expression .)
    EQMINUS         reduce using rule 57 (primary_expression -> expression .)
    TIMES           reduce using rule 57 (primary_expression -> expression .)
    DIVIDE          reduce using rule 57 (primary_expression -> expression .)
    MOD             reduce using rule 57 (primary_expression -> expression .)
    PLUS            reduce using rule 57 (primary_expression -> expression .)
    MINUS           reduce using rule 57 (primary_expression -> expression .)
    LT              reduce using rule 57 (primary_expression -> expression .)
    LE              reduce using rule 57 (primary_expression -> expression .)
    GT              reduce using rule 57 (primary_expression -> expression .)
    GE              reduce using rule 57 (primary_expression -> expression .)
    EQ              reduce using rule 57 (primary_expression -> expression .)
    NQ              reduce using rule 57 (primary_expression -> expression .)
    AND             reduce using rule 57 (primary_expression -> expression .)
    OR              reduce using rule 57 (primary_expression -> expression .)

  ! RBRACKET        [ reduce using rule 57 (primary_expression -> expression .) ]
  ! COMMA           [ reduce using rule 57 (primary_expression -> expression .) ]


state 156

    (49) postfix_expression -> postfix_expression LPAREN argument_expression_opt . RPAREN

    RPAREN          shift and go to state 173


state 157

    (52) argument_expression_opt -> argument_expression .
    (64) argument_expression -> argument_expression . COMMA assignment_expression

    RPAREN          reduce using rule 52 (argument_expression_opt -> argument_expression .)
    COMMA           shift and go to state 174


state 158

    (53) argument_expression_opt -> empty .

    RPAREN          reduce using rule 53 (argument_expression_opt -> empty .)


state 159

    (63) argument_expression -> assignment_expression .
    (61) expression -> assignment_expression .

  ! reduce/reduce conflict for COMMA resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (expression -> assignment_expression .)
    COMMA           reduce using rule 61 (expression -> assignment_expression .)
    RPAREN          reduce using rule 61 (expression -> assignment_expression .)
    LBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    LPAREN          reduce using rule 61 (expression -> assignment_expression .)
    INCREASE        reduce using rule 61 (expression -> assignment_expression .)
    DECREASE        reduce using rule 61 (expression -> assignment_expression .)
    EQUALS          reduce using rule 61 (expression -> assignment_expression .)
    EQTIMES         reduce using rule 61 (expression -> assignment_expression .)
    EQDIV           reduce using rule 61 (expression -> assignment_expression .)
    EQMOD           reduce using rule 61 (expression -> assignment_expression .)
    EQPLUS          reduce using rule 61 (expression -> assignment_expression .)
    EQMINUS         reduce using rule 61 (expression -> assignment_expression .)
    TIMES           reduce using rule 61 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 61 (expression -> assignment_expression .)
    MOD             reduce using rule 61 (expression -> assignment_expression .)
    PLUS            reduce using rule 61 (expression -> assignment_expression .)
    MINUS           reduce using rule 61 (expression -> assignment_expression .)
    LT              reduce using rule 61 (expression -> assignment_expression .)
    LE              reduce using rule 61 (expression -> assignment_expression .)
    GT              reduce using rule 61 (expression -> assignment_expression .)
    GE              reduce using rule 61 (expression -> assignment_expression .)
    EQ              reduce using rule 61 (expression -> assignment_expression .)
    NQ              reduce using rule 61 (expression -> assignment_expression .)
    AND             reduce using rule 61 (expression -> assignment_expression .)
    OR              reduce using rule 61 (expression -> assignment_expression .)

  ! COMMA           [ reduce using rule 63 (argument_expression -> assignment_expression .) ]
  ! RPAREN          [ reduce using rule 63 (argument_expression -> assignment_expression .) ]


state 160

    (62) expression -> expression COMMA assignment_expression .
    (61) expression -> assignment_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LT resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for GT resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for GE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for AND resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for OR resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (expression -> assignment_expression .)
    EQUALS          reduce using rule 61 (expression -> assignment_expression .)
    EQTIMES         reduce using rule 61 (expression -> assignment_expression .)
    EQDIV           reduce using rule 61 (expression -> assignment_expression .)
    EQMOD           reduce using rule 61 (expression -> assignment_expression .)
    EQPLUS          reduce using rule 61 (expression -> assignment_expression .)
    EQMINUS         reduce using rule 61 (expression -> assignment_expression .)
    TIMES           reduce using rule 61 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 61 (expression -> assignment_expression .)
    MOD             reduce using rule 61 (expression -> assignment_expression .)
    PLUS            reduce using rule 61 (expression -> assignment_expression .)
    MINUS           reduce using rule 61 (expression -> assignment_expression .)
    LT              reduce using rule 61 (expression -> assignment_expression .)
    LE              reduce using rule 61 (expression -> assignment_expression .)
    GT              reduce using rule 61 (expression -> assignment_expression .)
    GE              reduce using rule 61 (expression -> assignment_expression .)
    EQ              reduce using rule 61 (expression -> assignment_expression .)
    NQ              reduce using rule 61 (expression -> assignment_expression .)
    AND             reduce using rule 61 (expression -> assignment_expression .)
    OR              reduce using rule 61 (expression -> assignment_expression .)
    RBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    COMMA           reduce using rule 61 (expression -> assignment_expression .)
    LBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    LPAREN          reduce using rule 61 (expression -> assignment_expression .)
    INCREASE        reduce using rule 61 (expression -> assignment_expression .)
    DECREASE        reduce using rule 61 (expression -> assignment_expression .)
    SEMI            reduce using rule 61 (expression -> assignment_expression .)
    RPAREN          reduce using rule 61 (expression -> assignment_expression .)

  ! TIMES           [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! DIVIDE          [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! MOD             [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! PLUS            [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! MINUS           [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! LT              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! LE              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! GT              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! GE              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQ              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! NQ              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! AND             [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! OR              [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! RBRACKET        [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! COMMA           [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! LBRACKET        [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! LPAREN          [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! INCREASE        [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! DECREASE        [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQUALS          [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQTIMES         [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQDIV           [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQMOD           [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQPLUS          [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! EQMINUS         [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! SEMI            [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]
  ! RPAREN          [ reduce using rule 62 (expression -> expression COMMA assignment_expression .) ]


state 161

    (79) parameter_list -> parameter_list COMMA parameter_declaration .

    RPAREN          reduce using rule 79 (parameter_list -> parameter_list COMMA parameter_declaration .)
    COMMA           reduce using rule 79 (parameter_list -> parameter_list COMMA parameter_declaration .)


state 162

    (107) selection_statement -> IF LPAREN expression . RPAREN statement
    (108) selection_statement -> IF LPAREN expression . RPAREN statement ELSE statement
    (62) expression -> expression . COMMA assignment_expression
    (57) primary_expression -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          shift and go to state 175
    COMMA           shift and go to state 125
    LBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LPAREN          reduce using rule 57 (primary_expression -> expression .)
    INCREASE        reduce using rule 57 (primary_expression -> expression .)
    DECREASE        reduce using rule 57 (primary_expression -> expression .)
    EQUALS          reduce using rule 57 (primary_expression -> expression .)
    EQTIMES         reduce using rule 57 (primary_expression -> expression .)
    EQDIV           reduce using rule 57 (primary_expression -> expression .)
    EQMOD           reduce using rule 57 (primary_expression -> expression .)
    EQPLUS          reduce using rule 57 (primary_expression -> expression .)
    EQMINUS         reduce using rule 57 (primary_expression -> expression .)
    TIMES           reduce using rule 57 (primary_expression -> expression .)
    DIVIDE          reduce using rule 57 (primary_expression -> expression .)
    MOD             reduce using rule 57 (primary_expression -> expression .)
    PLUS            reduce using rule 57 (primary_expression -> expression .)
    MINUS           reduce using rule 57 (primary_expression -> expression .)
    LT              reduce using rule 57 (primary_expression -> expression .)
    LE              reduce using rule 57 (primary_expression -> expression .)
    GT              reduce using rule 57 (primary_expression -> expression .)
    GE              reduce using rule 57 (primary_expression -> expression .)
    EQ              reduce using rule 57 (primary_expression -> expression .)
    NQ              reduce using rule 57 (primary_expression -> expression .)
    AND             reduce using rule 57 (primary_expression -> expression .)
    OR              reduce using rule 57 (primary_expression -> expression .)

  ! RPAREN          [ reduce using rule 57 (primary_expression -> expression .) ]
  ! COMMA           [ reduce using rule 57 (primary_expression -> expression .) ]


state 163

    (109) iteration_statement -> WHILE LPAREN expression . RPAREN statement
    (62) expression -> expression . COMMA assignment_expression
    (57) primary_expression -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          shift and go to state 176
    COMMA           shift and go to state 125
    LBRACKET        reduce using rule 57 (primary_expression -> expression .)
    LPAREN          reduce using rule 57 (primary_expression -> expression .)
    INCREASE        reduce using rule 57 (primary_expression -> expression .)
    DECREASE        reduce using rule 57 (primary_expression -> expression .)
    EQUALS          reduce using rule 57 (primary_expression -> expression .)
    EQTIMES         reduce using rule 57 (primary_expression -> expression .)
    EQDIV           reduce using rule 57 (primary_expression -> expression .)
    EQMOD           reduce using rule 57 (primary_expression -> expression .)
    EQPLUS          reduce using rule 57 (primary_expression -> expression .)
    EQMINUS         reduce using rule 57 (primary_expression -> expression .)
    TIMES           reduce using rule 57 (primary_expression -> expression .)
    DIVIDE          reduce using rule 57 (primary_expression -> expression .)
    MOD             reduce using rule 57 (primary_expression -> expression .)
    PLUS            reduce using rule 57 (primary_expression -> expression .)
    MINUS           reduce using rule 57 (primary_expression -> expression .)
    LT              reduce using rule 57 (primary_expression -> expression .)
    LE              reduce using rule 57 (primary_expression -> expression .)
    GT              reduce using rule 57 (primary_expression -> expression .)
    GE              reduce using rule 57 (primary_expression -> expression .)
    EQ              reduce using rule 57 (primary_expression -> expression .)
    NQ              reduce using rule 57 (primary_expression -> expression .)
    AND             reduce using rule 57 (primary_expression -> expression .)
    OR              reduce using rule 57 (primary_expression -> expression .)

  ! RPAREN          [ reduce using rule 57 (primary_expression -> expression .) ]
  ! COMMA           [ reduce using rule 57 (primary_expression -> expression .) ]


state 164

    (110) iteration_statement -> FOR LPAREN expression_opt . SEMI expression_opt SEMI expression_opt RPAREN statement

    SEMI            shift and go to state 177


state 165

    (111) iteration_statement -> FOR LPAREN declaration . SEMI expression_opt SEMI expression_opt RPAREN statement

    SEMI            shift and go to state 178


state 166

    (113) jump_statement -> RETURN expression_opt SEMI .

    IF              reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    WHILE           reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    FOR             reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    BREAK           reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    RETURN          reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    ASSERT          reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    PRINT           reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    READ            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    VOID            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    CHAR            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    INT             reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    FLOAT           reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    INCREASE        reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    DECREASE        reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    LPAREN          reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    ADDRESS         reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    TIMES           reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    PLUS            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    MINUS           reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    NOT             reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    STRING          reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    ID              reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    INT_CONST       reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    CHAR_CONST      reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    FLOAT_CONST     reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    SEMI            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    $end            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)
    ELSE            reduce using rule 113 (jump_statement -> RETURN expression_opt SEMI .)


state 167

    (114) assert_statement -> ASSERT expression SEMI .

    IF              reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    WHILE           reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    FOR             reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    BREAK           reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    RETURN          reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    ASSERT          reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    PRINT           reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    READ            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    VOID            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    CHAR            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    INT             reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    FLOAT           reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    INCREASE        reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    DECREASE        reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    LPAREN          reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    ADDRESS         reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    TIMES           reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    PLUS            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    MINUS           reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    NOT             reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    STRING          reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    ID              reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    INT_CONST       reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    CHAR_CONST      reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    FLOAT_CONST     reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    SEMI            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    $end            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)
    ELSE            reduce using rule 114 (assert_statement -> ASSERT expression SEMI .)


state 168

    (115) print_statement -> PRINT LPAREN expression_opt . RPAREN SEMI

    RPAREN          shift and go to state 179


state 169

    (116) read_statement -> READ LPAREN argument_expression . RPAREN SEMI
    (64) argument_expression -> argument_expression . COMMA assignment_expression

    RPAREN          shift and go to state 180
    COMMA           shift and go to state 174


state 170

    (92) initializer_list -> initializer_list COMMA initializer .
    (91) initializer_list -> initializer .

  ! reduce/reduce conflict for COMMA resolved using rule 91 (initializer_list -> initializer .)
  ! reduce/reduce conflict for SEMI resolved using rule 91 (initializer_list -> initializer .)
    COMMA           reduce using rule 91 (initializer_list -> initializer .)
    SEMI            reduce using rule 91 (initializer_list -> initializer .)

  ! COMMA           [ reduce using rule 92 (initializer_list -> initializer_list COMMA initializer .) ]
  ! SEMI            [ reduce using rule 92 (initializer_list -> initializer_list COMMA initializer .) ]


state 171

    (42) cast_expression -> LPAREN type_specifier RPAREN cast_expression .
    (27) binary_expression -> cast_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQTIMES resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQDIV resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQMOD resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQPLUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQMINUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for MOD resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LT resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for GT resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for GE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for EQ resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for NQ resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for AND resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for OR resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for INCREASE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for DECREASE resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for SEMI resolved using rule 27 (binary_expression -> cast_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (binary_expression -> cast_expression .)
    EQUALS          reduce using rule 27 (binary_expression -> cast_expression .)
    EQTIMES         reduce using rule 27 (binary_expression -> cast_expression .)
    EQDIV           reduce using rule 27 (binary_expression -> cast_expression .)
    EQMOD           reduce using rule 27 (binary_expression -> cast_expression .)
    EQPLUS          reduce using rule 27 (binary_expression -> cast_expression .)
    EQMINUS         reduce using rule 27 (binary_expression -> cast_expression .)
    TIMES           reduce using rule 27 (binary_expression -> cast_expression .)
    DIVIDE          reduce using rule 27 (binary_expression -> cast_expression .)
    MOD             reduce using rule 27 (binary_expression -> cast_expression .)
    PLUS            reduce using rule 27 (binary_expression -> cast_expression .)
    MINUS           reduce using rule 27 (binary_expression -> cast_expression .)
    LT              reduce using rule 27 (binary_expression -> cast_expression .)
    LE              reduce using rule 27 (binary_expression -> cast_expression .)
    GT              reduce using rule 27 (binary_expression -> cast_expression .)
    GE              reduce using rule 27 (binary_expression -> cast_expression .)
    EQ              reduce using rule 27 (binary_expression -> cast_expression .)
    NQ              reduce using rule 27 (binary_expression -> cast_expression .)
    AND             reduce using rule 27 (binary_expression -> cast_expression .)
    OR              reduce using rule 27 (binary_expression -> cast_expression .)
    RBRACKET        reduce using rule 27 (binary_expression -> cast_expression .)
    COMMA           reduce using rule 27 (binary_expression -> cast_expression .)
    LBRACKET        reduce using rule 27 (binary_expression -> cast_expression .)
    LPAREN          reduce using rule 27 (binary_expression -> cast_expression .)
    INCREASE        reduce using rule 27 (binary_expression -> cast_expression .)
    DECREASE        reduce using rule 27 (binary_expression -> cast_expression .)
    SEMI            reduce using rule 27 (binary_expression -> cast_expression .)
    RPAREN          reduce using rule 27 (binary_expression -> cast_expression .)

  ! TIMES           [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! DIVIDE          [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! MOD             [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! PLUS            [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! MINUS           [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! LT              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! LE              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! GT              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! GE              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQ              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! NQ              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! AND             [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! OR              [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! RBRACKET        [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! COMMA           [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! LBRACKET        [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! LPAREN          [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! INCREASE        [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! DECREASE        [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQUALS          [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQTIMES         [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQDIV           [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQMOD           [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQPLUS          [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! EQMINUS         [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! SEMI            [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]
  ! RPAREN          [ reduce using rule 42 (cast_expression -> LPAREN type_specifier RPAREN cast_expression .) ]


state 172

    (48) postfix_expression -> postfix_expression LBRACKET expression RBRACKET .

    TIMES           reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    MOD             reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    LT              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    LE              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    GT              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    GE              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQ              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    NQ              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    AND             reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    OR              reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    INCREASE        reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    DECREASE        reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQUALS          reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQTIMES         reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQDIV           reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQMOD           reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQPLUS          reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    EQMINUS         reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    SEMI            reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 48 (postfix_expression -> postfix_expression LBRACKET expression RBRACKET .)


state 173

    (49) postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .

    TIMES           reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    DIVIDE          reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    MOD             reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    PLUS            reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    MINUS           reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    LT              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    LE              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    GT              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    GE              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQ              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    NQ              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    AND             reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    OR              reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    RBRACKET        reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    COMMA           reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    LBRACKET        reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    LPAREN          reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    INCREASE        reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    DECREASE        reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQUALS          reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQTIMES         reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQDIV           reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQMOD           reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQPLUS          reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    EQMINUS         reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    SEMI            reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)
    RPAREN          reduce using rule 49 (postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN .)


state 174

    (64) argument_expression -> argument_expression COMMA . assignment_expression
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression

    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    assignment_expression          shift and go to state 181
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    expression                     shift and go to state 54
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 175

    (107) selection_statement -> IF LPAREN expression RPAREN . statement
    (108) selection_statement -> IF LPAREN expression RPAREN . statement ELSE statement
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    SEMI            reduce using rule 117 (empty -> .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 80
    statement                      shift and go to state 182
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    expression_opt                 shift and go to state 78
    declaration_list               shift and go to state 31
    declaration                    shift and go to state 19
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    type_specifier                 shift and go to state 20
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 176

    (109) iteration_statement -> WHILE LPAREN expression RPAREN . statement
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    SEMI            reduce using rule 117 (empty -> .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 80
    statement                      shift and go to state 183
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    expression_opt                 shift and go to state 78
    declaration_list               shift and go to state 31
    declaration                    shift and go to state 19
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    type_specifier                 shift and go to state 20
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 177

    (110) iteration_statement -> FOR LPAREN expression_opt SEMI . expression_opt SEMI expression_opt RPAREN statement
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    SEMI            reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 184
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 178

    (111) iteration_statement -> FOR LPAREN declaration SEMI . expression_opt SEMI expression_opt RPAREN statement
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    SEMI            reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 185
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 179

    (115) print_statement -> PRINT LPAREN expression_opt RPAREN . SEMI

    SEMI            shift and go to state 186


state 180

    (116) read_statement -> READ LPAREN argument_expression RPAREN . SEMI

    SEMI            shift and go to state 187


state 181

    (64) argument_expression -> argument_expression COMMA assignment_expression .
    (61) expression -> assignment_expression .

  ! reduce/reduce conflict for COMMA resolved using rule 61 (expression -> assignment_expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (expression -> assignment_expression .)
    TIMES           reduce using rule 61 (expression -> assignment_expression .)
    DIVIDE          reduce using rule 61 (expression -> assignment_expression .)
    MOD             reduce using rule 61 (expression -> assignment_expression .)
    PLUS            reduce using rule 61 (expression -> assignment_expression .)
    MINUS           reduce using rule 61 (expression -> assignment_expression .)
    LT              reduce using rule 61 (expression -> assignment_expression .)
    LE              reduce using rule 61 (expression -> assignment_expression .)
    GT              reduce using rule 61 (expression -> assignment_expression .)
    GE              reduce using rule 61 (expression -> assignment_expression .)
    EQ              reduce using rule 61 (expression -> assignment_expression .)
    NQ              reduce using rule 61 (expression -> assignment_expression .)
    AND             reduce using rule 61 (expression -> assignment_expression .)
    OR              reduce using rule 61 (expression -> assignment_expression .)
    COMMA           reduce using rule 61 (expression -> assignment_expression .)
    RPAREN          reduce using rule 61 (expression -> assignment_expression .)
    LBRACKET        reduce using rule 61 (expression -> assignment_expression .)
    LPAREN          reduce using rule 61 (expression -> assignment_expression .)
    INCREASE        reduce using rule 61 (expression -> assignment_expression .)
    DECREASE        reduce using rule 61 (expression -> assignment_expression .)
    EQUALS          reduce using rule 61 (expression -> assignment_expression .)
    EQTIMES         reduce using rule 61 (expression -> assignment_expression .)
    EQDIV           reduce using rule 61 (expression -> assignment_expression .)
    EQMOD           reduce using rule 61 (expression -> assignment_expression .)
    EQPLUS          reduce using rule 61 (expression -> assignment_expression .)
    EQMINUS         reduce using rule 61 (expression -> assignment_expression .)

  ! COMMA           [ reduce using rule 64 (argument_expression -> argument_expression COMMA assignment_expression .) ]
  ! RPAREN          [ reduce using rule 64 (argument_expression -> argument_expression COMMA assignment_expression .) ]


state 182

    (107) selection_statement -> IF LPAREN expression RPAREN statement .
    (108) selection_statement -> IF LPAREN expression RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    ASSERT          reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    PRINT           reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    READ            reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    VOID            reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INT             reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INCREASE        reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    DECREASE        reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    ADDRESS         reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    TIMES           reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    NOT             reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    STRING          reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    ID              reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    INT_CONST       reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    CHAR_CONST      reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT_CONST     reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    SEMI            reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    $end            reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .)
    ELSE            shift and go to state 188

  ! ELSE            [ reduce using rule 107 (selection_statement -> IF LPAREN expression RPAREN statement .) ]


state 183

    (109) iteration_statement -> WHILE LPAREN expression RPAREN statement .

    IF              reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    ASSERT          reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    PRINT           reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    READ            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INCREASE        reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    DECREASE        reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    ADDRESS         reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    TIMES           reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    ID              reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    INT_CONST       reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR_CONST      reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT_CONST     reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    SEMI            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    $end            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 109 (iteration_statement -> WHILE LPAREN expression RPAREN statement .)


state 184

    (110) iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt . SEMI expression_opt RPAREN statement

    SEMI            shift and go to state 189


state 185

    (111) iteration_statement -> FOR LPAREN declaration SEMI expression_opt . SEMI expression_opt RPAREN statement

    SEMI            shift and go to state 190


state 186

    (115) print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .

    IF              reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    WHILE           reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    FOR             reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    BREAK           reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    RETURN          reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    ASSERT          reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    PRINT           reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    READ            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    VOID            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    CHAR            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    INT             reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    FLOAT           reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    INCREASE        reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    DECREASE        reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    LPAREN          reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    ADDRESS         reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    TIMES           reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    PLUS            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    MINUS           reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    NOT             reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    STRING          reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    ID              reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    INT_CONST       reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    CHAR_CONST      reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    FLOAT_CONST     reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    SEMI            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    $end            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)
    ELSE            reduce using rule 115 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMI .)


state 187

    (116) read_statement -> READ LPAREN argument_expression RPAREN SEMI .

    IF              reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    WHILE           reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    FOR             reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    BREAK           reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    RETURN          reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    ASSERT          reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    PRINT           reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    READ            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    VOID            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    CHAR            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    INT             reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    FLOAT           reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    INCREASE        reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    DECREASE        reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    LPAREN          reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    ADDRESS         reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    TIMES           reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    PLUS            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    MINUS           reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    NOT             reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    STRING          reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    ID              reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    INT_CONST       reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    CHAR_CONST      reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    FLOAT_CONST     reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    SEMI            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    $end            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)
    ELSE            reduce using rule 116 (read_statement -> READ LPAREN argument_expression RPAREN SEMI .)


state 188

    (108) selection_statement -> IF LPAREN expression RPAREN statement ELSE . statement
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    SEMI            reduce using rule 117 (empty -> .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression                     shift and go to state 80
    statement                      shift and go to state 191
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    expression_opt                 shift and go to state 78
    declaration_list               shift and go to state 31
    declaration                    shift and go to state 19
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    type_specifier                 shift and go to state 20
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 189

    (110) iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI . expression_opt RPAREN statement
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    RPAREN          reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 192
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 190

    (111) iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI . expression_opt RPAREN statement
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    RPAREN          reduce using rule 117 (empty -> .)
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 193
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 191

    (108) selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .

    IF              reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    WHILE           reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    BREAK           reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    RETURN          reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ASSERT          reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    PRINT           reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    READ            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    VOID            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT             reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INCREASE        reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    DECREASE        reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ADDRESS         reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    TIMES           reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    PLUS            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    MINUS           reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NOT             reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    STRING          reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ID              reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT_CONST       reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR_CONST      reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT_CONST     reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    SEMI            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    $end            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 108 (selection_statement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 192

    (110) iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt . RPAREN statement

    RPAREN          shift and go to state 194


state 193

    (111) iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt . RPAREN statement

    RPAREN          shift and go to state 195


state 194

    (110) iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN . statement
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    SEMI            reduce using rule 117 (empty -> .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    expression_opt                 shift and go to state 78
    statement                      shift and go to state 196
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    declaration_list               shift and go to state 31
    expression                     shift and go to state 80
    declaration                    shift and go to state 19
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    type_specifier                 shift and go to state 20
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 195

    (111) iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN . statement
    (96) statement -> . expression_statement
    (97) statement -> . compound_statement
    (98) statement -> . selection_statement
    (99) statement -> . iteration_statement
    (100) statement -> . jump_statement
    (101) statement -> . assert_statement
    (102) statement -> . print_statement
    (103) statement -> . read_statement
    (104) expression_statement -> . expression_opt SEMI
    (93) compound_statement -> . declaration_list statement_list
    (107) selection_statement -> . IF LPAREN expression RPAREN statement
    (108) selection_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (109) iteration_statement -> . WHILE LPAREN expression RPAREN statement
    (110) iteration_statement -> . FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement
    (111) iteration_statement -> . FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement
    (112) jump_statement -> . BREAK
    (113) jump_statement -> . RETURN expression_opt SEMI
    (114) assert_statement -> . ASSERT expression SEMI
    (115) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMI
    (116) read_statement -> . READ LPAREN argument_expression RPAREN SEMI
    (105) expression_opt -> . expression
    (106) expression_opt -> . empty
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list declaration
    (61) expression -> . assignment_expression
    (62) expression -> . expression COMMA assignment_expression
    (117) empty -> .
    (81) declaration -> . type_specifier init_declarator_list_opt SEMI
    (65) assignment_expression -> . binary_expression
    (66) assignment_expression -> . unary_expression assignment_operator assignment_expression
    (11) type_specifier -> . VOID
    (12) type_specifier -> . CHAR
    (13) type_specifier -> . INT
    (14) type_specifier -> . FLOAT
    (27) binary_expression -> . cast_expression
    (28) binary_expression -> . binary_expression TIMES binary_expression
    (29) binary_expression -> . binary_expression DIVIDE binary_expression
    (30) binary_expression -> . binary_expression MOD binary_expression
    (31) binary_expression -> . binary_expression PLUS binary_expression
    (32) binary_expression -> . binary_expression MINUS binary_expression
    (33) binary_expression -> . binary_expression LT binary_expression
    (34) binary_expression -> . binary_expression LE binary_expression
    (35) binary_expression -> . binary_expression GT binary_expression
    (36) binary_expression -> . binary_expression GE binary_expression
    (37) binary_expression -> . binary_expression EQ binary_expression
    (38) binary_expression -> . binary_expression NQ binary_expression
    (39) binary_expression -> . binary_expression AND binary_expression
    (40) binary_expression -> . binary_expression OR binary_expression
    (43) unary_expression -> . postfix_expression
    (44) unary_expression -> . INCREASE unary_expression
    (45) unary_expression -> . DECREASE unary_expression
    (46) unary_expression -> . unary_operator cast_expression
    (41) cast_expression -> . unary_expression
    (42) cast_expression -> . LPAREN type_specifier RPAREN cast_expression
    (47) postfix_expression -> . primary_expression
    (48) postfix_expression -> . postfix_expression LBRACKET expression RBRACKET
    (49) postfix_expression -> . postfix_expression LPAREN argument_expression_opt RPAREN
    (50) postfix_expression -> . postfix_expression INCREASE
    (51) postfix_expression -> . postfix_expression DECREASE
    (73) unary_operator -> . ADDRESS
    (74) unary_operator -> . TIMES
    (75) unary_operator -> . PLUS
    (76) unary_operator -> . MINUS
    (77) unary_operator -> . NOT
    (54) primary_expression -> . identifier
    (55) primary_expression -> . constant
    (56) primary_expression -> . STRING
    (57) primary_expression -> . expression
    (10) identifier -> . ID
    (58) constant -> . INT_CONST
    (59) constant -> . CHAR_CONST
    (60) constant -> . FLOAT_CONST

    IF              shift and go to state 79
    WHILE           shift and go to state 81
    FOR             shift and go to state 82
    BREAK           shift and go to state 83
    RETURN          shift and go to state 84
    ASSERT          shift and go to state 85
    PRINT           shift and go to state 86
    READ            shift and go to state 87
    SEMI            reduce using rule 117 (empty -> .)
    VOID            shift and go to state 10
    CHAR            shift and go to state 11
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    INCREASE        shift and go to state 50
    DECREASE        shift and go to state 51
    LPAREN          shift and go to state 48
    ADDRESS         shift and go to state 55
    TIMES           shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    NOT             shift and go to state 56
    STRING          shift and go to state 59
    ID              shift and go to state 16
    INT_CONST       shift and go to state 60
    CHAR_CONST      shift and go to state 61
    FLOAT_CONST     shift and go to state 62

    declaration                    shift and go to state 19
    expression_opt                 shift and go to state 78
    statement                      shift and go to state 197
    expression_statement           shift and go to state 70
    compound_statement             shift and go to state 71
    selection_statement            shift and go to state 72
    iteration_statement            shift and go to state 73
    jump_statement                 shift and go to state 74
    assert_statement               shift and go to state 75
    print_statement                shift and go to state 76
    read_statement                 shift and go to state 77
    declaration_list               shift and go to state 31
    expression                     shift and go to state 80
    empty                          shift and go to state 88
    assignment_expression          shift and go to state 63
    type_specifier                 shift and go to state 20
    binary_expression              shift and go to state 89
    unary_expression               shift and go to state 90
    cast_expression                shift and go to state 43
    postfix_expression             shift and go to state 49
    unary_operator                 shift and go to state 52
    primary_expression             shift and go to state 53
    identifier                     shift and go to state 57
    constant                       shift and go to state 58

state 196

    (110) iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .

    IF              reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    WHILE           reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    FOR             reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    BREAK           reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    RETURN          reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ASSERT          reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    PRINT           reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    READ            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    VOID            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    CHAR            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    INT             reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    FLOAT           reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    INCREASE        reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    DECREASE        reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    LPAREN          reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ADDRESS         reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    TIMES           reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    PLUS            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    MINUS           reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    NOT             reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    STRING          reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ID              reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    INT_CONST       reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    CHAR_CONST      reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    FLOAT_CONST     reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    SEMI            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    $end            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ELSE            reduce using rule 110 (iteration_statement -> FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement .)


state 197

    (111) iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .

    IF              reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    WHILE           reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    FOR             reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    BREAK           reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    RETURN          reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ASSERT          reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    PRINT           reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    READ            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    VOID            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    CHAR            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    INT             reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    FLOAT           reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    INCREASE        reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    DECREASE        reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    LPAREN          reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ADDRESS         reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    TIMES           reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    PLUS            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    MINUS           reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    NOT             reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    STRING          reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ID              reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    INT_CONST       reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    CHAR_CONST      reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    FLOAT_CONST     reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    SEMI            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    $end            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)
    ELSE            reduce using rule 111 (iteration_statement -> FOR LPAREN declaration SEMI expression_opt SEMI expression_opt RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 6 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 6 resolved as shift
WARNING: shift/reduce conflict for INT in state 6 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 6 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 8 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 8 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 21 resolved as shift
WARNING: shift/reduce conflict for VOID in state 21 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 21 resolved as shift
WARNING: shift/reduce conflict for INT in state 21 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 21 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 28 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 28 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 34 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 42 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 42 resolved as shift
WARNING: shift/reduce conflict for MOD in state 42 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for LT in state 42 resolved as shift
WARNING: shift/reduce conflict for LE in state 42 resolved as shift
WARNING: shift/reduce conflict for GT in state 42 resolved as shift
WARNING: shift/reduce conflict for GE in state 42 resolved as shift
WARNING: shift/reduce conflict for EQ in state 42 resolved as shift
WARNING: shift/reduce conflict for NQ in state 42 resolved as shift
WARNING: shift/reduce conflict for AND in state 42 resolved as shift
WARNING: shift/reduce conflict for OR in state 42 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 47 resolved as shift
WARNING: shift/reduce conflict for EQTIMES in state 47 resolved as shift
WARNING: shift/reduce conflict for EQDIV in state 47 resolved as shift
WARNING: shift/reduce conflict for EQMOD in state 47 resolved as shift
WARNING: shift/reduce conflict for EQPLUS in state 47 resolved as shift
WARNING: shift/reduce conflict for EQMINUS in state 47 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 49 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 49 resolved as shift
WARNING: shift/reduce conflict for INCREASE in state 49 resolved as shift
WARNING: shift/reduce conflict for DECREASE in state 49 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 68 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 68 resolved as shift
WARNING: shift/reduce conflict for FOR in state 68 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 68 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 68 resolved as shift
WARNING: shift/reduce conflict for ASSERT in state 68 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 68 resolved as shift
WARNING: shift/reduce conflict for READ in state 68 resolved as shift
WARNING: shift/reduce conflict for VOID in state 68 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 68 resolved as shift
WARNING: shift/reduce conflict for INT in state 68 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 68 resolved as shift
WARNING: shift/reduce conflict for INCREASE in state 68 resolved as shift
WARNING: shift/reduce conflict for DECREASE in state 68 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 68 resolved as shift
WARNING: shift/reduce conflict for ADDRESS in state 68 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for NOT in state 68 resolved as shift
WARNING: shift/reduce conflict for STRING in state 68 resolved as shift
WARNING: shift/reduce conflict for ID in state 68 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 68 resolved as shift
WARNING: shift/reduce conflict for CHAR_CONST in state 68 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 68 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 80 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 89 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 89 resolved as shift
WARNING: shift/reduce conflict for MOD in state 89 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 89 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 89 resolved as shift
WARNING: shift/reduce conflict for LT in state 89 resolved as shift
WARNING: shift/reduce conflict for LE in state 89 resolved as shift
WARNING: shift/reduce conflict for GT in state 89 resolved as shift
WARNING: shift/reduce conflict for GE in state 89 resolved as shift
WARNING: shift/reduce conflict for EQ in state 89 resolved as shift
WARNING: shift/reduce conflict for NQ in state 89 resolved as shift
WARNING: shift/reduce conflict for AND in state 89 resolved as shift
WARNING: shift/reduce conflict for OR in state 89 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 90 resolved as shift
WARNING: shift/reduce conflict for EQTIMES in state 90 resolved as shift
WARNING: shift/reduce conflict for EQDIV in state 90 resolved as shift
WARNING: shift/reduce conflict for EQMOD in state 90 resolved as shift
WARNING: shift/reduce conflict for EQPLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for EQMINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 94 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 122 resolved as shift
WARNING: shift/reduce conflict for EQTIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for EQDIV in state 122 resolved as shift
WARNING: shift/reduce conflict for EQMOD in state 122 resolved as shift
WARNING: shift/reduce conflict for EQPLUS in state 122 resolved as shift
WARNING: shift/reduce conflict for EQMINUS in state 122 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 123 resolved as shift
WARNING: shift/reduce conflict for EQTIMES in state 123 resolved as shift
WARNING: shift/reduce conflict for EQDIV in state 123 resolved as shift
WARNING: shift/reduce conflict for EQMOD in state 123 resolved as shift
WARNING: shift/reduce conflict for EQPLUS in state 123 resolved as shift
WARNING: shift/reduce conflict for EQMINUS in state 123 resolved as shift
WARNING: shift/reduce conflict for SEMI in state 136 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 136 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for MOD in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for LT in state 142 resolved as shift
WARNING: shift/reduce conflict for LE in state 142 resolved as shift
WARNING: shift/reduce conflict for GT in state 142 resolved as shift
WARNING: shift/reduce conflict for GE in state 142 resolved as shift
WARNING: shift/reduce conflict for EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for NQ in state 142 resolved as shift
WARNING: shift/reduce conflict for AND in state 142 resolved as shift
WARNING: shift/reduce conflict for OR in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for MOD in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for LT in state 142 resolved as shift
WARNING: shift/reduce conflict for LE in state 142 resolved as shift
WARNING: shift/reduce conflict for GT in state 142 resolved as shift
WARNING: shift/reduce conflict for GE in state 142 resolved as shift
WARNING: shift/reduce conflict for EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for NQ in state 142 resolved as shift
WARNING: shift/reduce conflict for AND in state 142 resolved as shift
WARNING: shift/reduce conflict for OR in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 144 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 144 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 145 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MOD in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for LT in state 146 resolved as shift
WARNING: shift/reduce conflict for LE in state 146 resolved as shift
WARNING: shift/reduce conflict for GT in state 146 resolved as shift
WARNING: shift/reduce conflict for GE in state 146 resolved as shift
WARNING: shift/reduce conflict for EQ in state 146 resolved as shift
WARNING: shift/reduce conflict for NQ in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MOD in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for LT in state 146 resolved as shift
WARNING: shift/reduce conflict for LE in state 146 resolved as shift
WARNING: shift/reduce conflict for GT in state 146 resolved as shift
WARNING: shift/reduce conflict for GE in state 146 resolved as shift
WARNING: shift/reduce conflict for EQ in state 146 resolved as shift
WARNING: shift/reduce conflict for NQ in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for MOD in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for LT in state 148 resolved as shift
WARNING: shift/reduce conflict for LE in state 148 resolved as shift
WARNING: shift/reduce conflict for GT in state 148 resolved as shift
WARNING: shift/reduce conflict for GE in state 148 resolved as shift
WARNING: shift/reduce conflict for EQ in state 148 resolved as shift
WARNING: shift/reduce conflict for NQ in state 148 resolved as shift
WARNING: shift/reduce conflict for AND in state 148 resolved as shift
WARNING: shift/reduce conflict for OR in state 148 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for MOD in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for LT in state 148 resolved as shift
WARNING: shift/reduce conflict for LE in state 148 resolved as shift
WARNING: shift/reduce conflict for GT in state 148 resolved as shift
WARNING: shift/reduce conflict for GE in state 148 resolved as shift
WARNING: shift/reduce conflict for EQ in state 148 resolved as shift
WARNING: shift/reduce conflict for NQ in state 148 resolved as shift
WARNING: shift/reduce conflict for AND in state 148 resolved as shift
WARNING: shift/reduce conflict for OR in state 148 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for MOD in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for LT in state 149 resolved as shift
WARNING: shift/reduce conflict for LE in state 149 resolved as shift
WARNING: shift/reduce conflict for GT in state 149 resolved as shift
WARNING: shift/reduce conflict for GE in state 149 resolved as shift
WARNING: shift/reduce conflict for EQ in state 149 resolved as shift
WARNING: shift/reduce conflict for NQ in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for OR in state 149 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for MOD in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for LT in state 149 resolved as shift
WARNING: shift/reduce conflict for LE in state 149 resolved as shift
WARNING: shift/reduce conflict for GT in state 149 resolved as shift
WARNING: shift/reduce conflict for GE in state 149 resolved as shift
WARNING: shift/reduce conflict for EQ in state 149 resolved as shift
WARNING: shift/reduce conflict for NQ in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for OR in state 149 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MOD in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for LT in state 150 resolved as shift
WARNING: shift/reduce conflict for LE in state 150 resolved as shift
WARNING: shift/reduce conflict for GT in state 150 resolved as shift
WARNING: shift/reduce conflict for GE in state 150 resolved as shift
WARNING: shift/reduce conflict for EQ in state 150 resolved as shift
WARNING: shift/reduce conflict for NQ in state 150 resolved as shift
WARNING: shift/reduce conflict for AND in state 150 resolved as shift
WARNING: shift/reduce conflict for OR in state 150 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MOD in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for LT in state 150 resolved as shift
WARNING: shift/reduce conflict for LE in state 150 resolved as shift
WARNING: shift/reduce conflict for GT in state 150 resolved as shift
WARNING: shift/reduce conflict for GE in state 150 resolved as shift
WARNING: shift/reduce conflict for EQ in state 150 resolved as shift
WARNING: shift/reduce conflict for NQ in state 150 resolved as shift
WARNING: shift/reduce conflict for AND in state 150 resolved as shift
WARNING: shift/reduce conflict for OR in state 150 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for MOD in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for LT in state 151 resolved as shift
WARNING: shift/reduce conflict for LE in state 151 resolved as shift
WARNING: shift/reduce conflict for GT in state 151 resolved as shift
WARNING: shift/reduce conflict for GE in state 151 resolved as shift
WARNING: shift/reduce conflict for EQ in state 151 resolved as shift
WARNING: shift/reduce conflict for NQ in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for MOD in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for LT in state 151 resolved as shift
WARNING: shift/reduce conflict for LE in state 151 resolved as shift
WARNING: shift/reduce conflict for GT in state 151 resolved as shift
WARNING: shift/reduce conflict for GE in state 151 resolved as shift
WARNING: shift/reduce conflict for EQ in state 151 resolved as shift
WARNING: shift/reduce conflict for NQ in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for MOD in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for LT in state 152 resolved as shift
WARNING: shift/reduce conflict for LE in state 152 resolved as shift
WARNING: shift/reduce conflict for GT in state 152 resolved as shift
WARNING: shift/reduce conflict for GE in state 152 resolved as shift
WARNING: shift/reduce conflict for EQ in state 152 resolved as shift
WARNING: shift/reduce conflict for NQ in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for MOD in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for LT in state 152 resolved as shift
WARNING: shift/reduce conflict for LE in state 152 resolved as shift
WARNING: shift/reduce conflict for GT in state 152 resolved as shift
WARNING: shift/reduce conflict for GE in state 152 resolved as shift
WARNING: shift/reduce conflict for EQ in state 152 resolved as shift
WARNING: shift/reduce conflict for NQ in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 155 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 155 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 162 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 163 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 182 resolved as shift
WARNING: reduce/reduce conflict in state 21 resolved using rule (direct_declarator -> declarator)
WARNING: rejected rule (init_declarator -> declarator) in state 21
WARNING: reduce/reduce conflict in state 28 resolved using rule (declarator -> direct_declarator)
WARNING: rejected rule (declarator -> pointer direct_declarator) in state 28
WARNING: reduce/reduce conflict in state 33 resolved using rule (declaration_list -> declaration)
WARNING: rejected rule (declaration_list -> declaration_list declaration) in state 33
WARNING: reduce/reduce conflict in state 34 resolved using rule (direct_declarator -> declarator)
WARNING: rejected rule (init_declarator -> declarator) in state 34
WARNING: reduce/reduce conflict in state 42 resolved using rule (constant_expression -> binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 42
WARNING: reduce/reduce conflict in state 68 resolved using rule (compound_statement -> declaration_list statement_list)
WARNING: rejected rule (empty -> <empty>) in state 68
WARNING: reduce/reduce conflict in state 80 resolved using rule (primary_expression -> expression)
WARNING: rejected rule (expression_opt -> expression) in state 80
WARNING: reduce/reduce conflict in state 92 resolved using rule (init_declarator -> declarator EQUALS initializer)
WARNING: rejected rule (initializer_list -> initializer) in state 92
WARNING: reduce/reduce conflict in state 93 resolved using rule (expression -> assignment_expression)
WARNING: rejected rule (initializer -> assignment_expression) in state 93
WARNING: reduce/reduce conflict in state 122 resolved using rule (cast_expression -> unary_expression)
WARNING: rejected rule (unary_expression -> INCREASE unary_expression) in state 122
WARNING: reduce/reduce conflict in state 123 resolved using rule (cast_expression -> unary_expression)
WARNING: rejected rule (unary_expression -> DECREASE unary_expression) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (binary_expression -> cast_expression)
WARNING: rejected rule (unary_expression -> unary_operator cast_expression) in state 124
WARNING: reduce/reduce conflict in state 129 resolved using rule (direct_declarator -> declarator)
WARNING: rejected rule (parameter_declaration -> type_specifier declarator) in state 129
WARNING: reduce/reduce conflict in state 140 resolved using rule (binary_expression -> binary_expression TIMES binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 140
WARNING: reduce/reduce conflict in state 141 resolved using rule (binary_expression -> binary_expression DIVIDE binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 141
WARNING: reduce/reduce conflict in state 142 resolved using rule (binary_expression -> binary_expression MOD binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 142
WARNING: reduce/reduce conflict in state 143 resolved using rule (binary_expression -> binary_expression PLUS binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 143
WARNING: reduce/reduce conflict in state 144 resolved using rule (binary_expression -> binary_expression MINUS binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 144
WARNING: reduce/reduce conflict in state 145 resolved using rule (binary_expression -> binary_expression LT binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 145
WARNING: reduce/reduce conflict in state 146 resolved using rule (binary_expression -> binary_expression LE binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 146
WARNING: reduce/reduce conflict in state 147 resolved using rule (binary_expression -> binary_expression GT binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 147
WARNING: reduce/reduce conflict in state 148 resolved using rule (binary_expression -> binary_expression GE binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 148
WARNING: reduce/reduce conflict in state 149 resolved using rule (binary_expression -> binary_expression EQ binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 149
WARNING: reduce/reduce conflict in state 150 resolved using rule (binary_expression -> binary_expression NQ binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 150
WARNING: reduce/reduce conflict in state 151 resolved using rule (binary_expression -> binary_expression AND binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 151
WARNING: reduce/reduce conflict in state 152 resolved using rule (binary_expression -> binary_expression OR binary_expression)
WARNING: rejected rule (assignment_expression -> binary_expression) in state 152
WARNING: reduce/reduce conflict in state 153 resolved using rule (expression -> assignment_expression)
WARNING: rejected rule (assignment_expression -> unary_expression assignment_operator assignment_expression) in state 153
WARNING: reduce/reduce conflict in state 159 resolved using rule (expression -> assignment_expression)
WARNING: rejected rule (argument_expression -> assignment_expression) in state 159
WARNING: reduce/reduce conflict in state 160 resolved using rule (expression -> assignment_expression)
WARNING: rejected rule (expression -> expression COMMA assignment_expression) in state 160
WARNING: reduce/reduce conflict in state 170 resolved using rule (initializer_list -> initializer)
WARNING: rejected rule (initializer_list -> initializer_list COMMA initializer) in state 170
WARNING: reduce/reduce conflict in state 171 resolved using rule (binary_expression -> cast_expression)
WARNING: rejected rule (cast_expression -> LPAREN type_specifier RPAREN cast_expression) in state 171
WARNING: reduce/reduce conflict in state 181 resolved using rule (expression -> assignment_expression)
WARNING: rejected rule (argument_expression -> argument_expression COMMA assignment_expression) in state 181
WARNING: Rule (init_declarator -> declarator) is never reduced
WARNING: Rule (declarator -> pointer direct_declarator) is never reduced
WARNING: Rule (declaration_list -> declaration_list declaration) is never reduced
WARNING: Rule (expression_opt -> expression) is never reduced
WARNING: Rule (initializer -> assignment_expression) is never reduced
WARNING: Rule (unary_expression -> INCREASE unary_expression) is never reduced
WARNING: Rule (unary_expression -> DECREASE unary_expression) is never reduced
WARNING: Rule (unary_expression -> unary_operator cast_expression) is never reduced
WARNING: Rule (parameter_declaration -> type_specifier declarator) is never reduced
WARNING: Rule (assignment_expression -> unary_expression assignment_operator assignment_expression) is never reduced
WARNING: Rule (argument_expression -> assignment_expression) is never reduced
WARNING: Rule (expression -> expression COMMA assignment_expression) is never reduced
WARNING: Rule (initializer_list -> initializer_list COMMA initializer) is never reduced
WARNING: Rule (cast_expression -> LPAREN type_specifier RPAREN cast_expression) is never reduced
WARNING: Rule (argument_expression -> argument_expression COMMA assignment_expression) is never reduced
